# 区块链中的密码学与安全技术

在区块链技术中，用到了大量的密码学知识来保证系统的安全性。密码学的分支很多，这篇文章仅仅对区块链中应用到的密码学知识，做一个较为全面的肤浅的介绍。

首先，会介绍一些密码学知识，然后，会介绍一些应用在区块链中的安全技术。总的来说，全文先介绍理论，后介绍理论的应用。全文将按照如下结构展开：

![img](https://pic3.zhimg.com/80/v2-e63ecd8b66caa1295d40dd9a5f6f19da_720w.jpg)全文架构

密码学可以分为古典密码学和现代密码学。

**古典密码学**主要关注信息的保密书写和传递，以及与其相对应的破译方法。

**现代密码学**不只关注信息保密问题，还同时涉及**信息完整性验证**（消息验证码）、信息发布的**不可抵赖性**（数字签名）、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。总而言之，现代密码学是互联网安全的基石。

------

## **一、密码学知识**

在现代密码学中，有众多的分支，分别维护者系统安全的不同角色。如上所述，为了确保信息的机密性、完整性、认证性和不可抵赖性，诞生了大量的安全算法。

其中，**和区块链相关的算法主要有哈希算法和加密解密算法。**接下来逐一介绍：

## **1.Hash函数**

**哈希函数的简介**

密码哈希函数是一类数学函数，可以在有限合理的时间内，将任意长度的消息压缩为固定长度的输出值，并且是不可逆的。其输出值**称为哈希值，也称为散列值。**

以哈希函数为基础构造的哈希算法，在现代密码学中扮演着重要的角色，常用于**实现数据完整性和实体认证**，同时也构成多种密码体制和协议的安全保障。接下来，将从这三个方面来简单分析一下Hash函数：

![img](https://pic3.zhimg.com/80/v2-0a1b21254591a5cabfd4bc495b931102_720w.jpg)Hash函数介绍导图

**哈希函数的评价标准**

一个优秀的Hash算法将能实现如下功能：

> **·正向快速**：给定明文和Hash算法，在有限时间和有限资源内能计算得到Hash值；
> **·逆向困难**：给定（若干）Hash值，在有限时间内很难（基本不可能）逆推出明文；
> **·输入敏感**：原始输入信息发生任何改变，新产生的Hash值都应该出现很大不同；
> **·冲突避免**：很难找到两段内容不同的明文，使得它们的Hash值一致（发生碰撞）。

```text
下面，来举一个输入敏感的例子，如下图所示：
```

![img](https://pic3.zhimg.com/80/v2-d0d4ea6ac062676a515831de05f3f476_720w.jpg)哈希值完全改变

```text
上图中，输入的改变，仅仅是将Hello的首字母，从小写改变为大写，
但是输出的哈希值就已经完全改变了。这说明MD5哈希函数的输入敏感度非常高！
```

碰撞是与哈希函数相关的重要概念，体现着哈希函数的安全性。

所谓碰撞是指两个不同的消息在同一个哈希函数作用下，具有相同的哈希值。哈希函数的安全性是指在现有的计算资源（包括时间、空间、资金等）下，找到一个碰撞是不可行的。

**冲突避免**有时候又称为“抗碰撞性”，分为“弱抗碰撞性”和“强抗碰撞性”。

如果给定明文前提下，无法找到与之碰撞的其他明文，则**算法具有“弱抗碰撞性”**；

如果无法找到任意两个发生Hash碰撞的明文，则称**算法具有“强抗碰撞性**”。



**哈希函数的种类**

目前常见的Hash算法包括MD和SHA系列算法。具体分类如下：

![img](https://pic4.zhimg.com/80/v2-7d26afbff9ceeb9dd40b0c6b8774a67f_720w.jpg)

> **MD4（**RFC 1320）是MIT的Ronald L.Rivest在1990年设计的，MD是Message Digest的缩写。其输出为128位。MD4已被证明不够安全。
>
> **MD5**（RFC 1321）是Rivest于1991年对MD4的改进版本。它对输入仍以512位进行分组，其输出是128位。MD5比MD4更加安全，但过程更加复杂，计算速度要慢一点。MD5已被证明不具备“强抗碰撞性”。
>
> **SHA（**Secure Hash Algorithm）并非一个算法，而是一个Hash函数族。NIST（National Institute of Standards and Technology）于1993年发布其首个实现。
>
> 目前知名的SHA-1算法在1995年面世，它的输出为长度160位的Hash值，抗穷举性更好。SHA-1设计时模仿了MD4算法，采用了类似原理。SHA-1已被证明不具备“强抗碰撞性”。
>
> NIST还设计出了SHA-224、SHA-256、SHA-384和SHA-512算法（统称为**SHA-2**），跟SHA-1算法原理类似。
>
> SHA-3相关算法也已被提出.

目前，MD5和SHA1已经被破解，一般推荐至少使用SHA2-256或更安全的算法。



**Hash函数在区块链中的应用**

在**比特币系统中**使用了两个密码学哈希函数，**一个是SHA256，另一个是RIPEMD160**。RIPEMD160主要用于生成比特币地址。

SHA256是构造区块链所用的主要密码哈希函数。

在**HyperLedger-Fabric区块链平台**中，Hash函数主要用于**检测数据未经授权的修改**，**签名者的身份识别和抗抵赖。**



## **2.加密解密算法**

加解密算法是密码学的核心技术。

**加密解密算法的分类**

从设计理念上可以分为两大基本类型，如下表所示：

![img](https://pic3.zhimg.com/80/v2-79c22c4a369a06d282952604e41282a6_720w.jpg)加解密算法的类型

**加解密系统基本组成**

现代加解密系统的典型组件一般包括：**加解密算法**、**加密密钥**、**解密密钥**。

在加解密系统中，加解密算法自身是固定不变的，并且一般是公开可见的；密钥则是最关键的信息，需要安全地保存起来，甚至通过特殊硬件进行保护。

一般来说，对同一种算法，**密钥需要**按照特定算法每次加密前**随机生成**，长度越长，则加密强度越大。加解密的基本过程如下图所示：

![img](https://pic3.zhimg.com/80/v2-c5077d8c284f195d114c6f8a819a7516_720w.jpg)加-解密-过程示意图

加密过程中，通过加密算法和加密密钥，对明文进行加密，获得密文。

解密过程中，通过解密算法和解密密钥，对密文进行解密，获得明文。

根据加解密过程中所使用的密钥是否相同，算法可以分为**对称加密**（symmetric cryptography，又称公共密钥加密，common-key cryptography）和**非对称加密**（asymmetric cryptography，又称公钥加密，public-key cryptography）。两种模式适用于不同的需求，恰好形成互补。某些时候可以组合使用，形成混合加密机制。

------

## **二、安全技术**

前面说到，现代密码学不只关注信息保密问题，还同时涉及信息完整性验证（消息验证码）、信息发布的不可抵赖性（数字签名）、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。

通过前面的介绍，我们知道了加密和解密算法实现了对信息的保密，哈希函数能够对任意的输入，输出长度一定的哈希值。

**怎么把这些理论用起来，以保证信息安全？**



## **1、消息认证码与数字签名**

消息认证码和数字签名技术通过**对消息的摘要进行加密**，可用于消息防篡改和身份证明问题。

**关于消息验证码**

**消息认证码**全称是“基于Hash的消息认证码”（Hash-based Message Authentication Code，HMAC）。

> 消息验证码**基于对称加密**，可以用于**对消息完整性（integrity）**进行保护。
>
> **基本过程为**：对某个消息利用提前共享的对称密钥和Hash算法进行加密处理，得到HMAC值。该HMAC值持有方可以证明自己拥有共享的对称密钥，并且也可以利用HMAC确保消息内容未被篡改。
>
> **一般用于证明身份的场景**
> 如Alice、Bob提前共享和HMCA的密钥和Hash算法，Alice需要知晓对方是否为Bob，可发送随机消息给Bob。Bob收到消息后进行计算，把消息HMAC值返回给Alice，Alice通过检验收到HMAC值的正确性可以知晓对方是否是Bob。注意这里并没有考虑中间人攻击的情况，假定信道是安全的。



**关于数字签名**

数字签名基于**非对称加密**，既可以用于**证实某数字内容的完整性**，又同时可以**确认来源**（或不可抵赖，Non-Repudiation）。

> 数字签名的**全过程分两大部分**，即**签名**与**验证**。一侧为签名，一侧为验证过程。
>
> **签名过程：**发方将原文用哈希算法求得数字摘要，用签名私钥对数字摘要加密得数字签名，发方将原文与数字签名一起发送给接受方。
>
> (**Q:** 为什么要将原文进行数字摘要之后，利用私钥和摘要，对原文进行签名，而不是直接用对原文进行签名？
> **A：**原因有二：
> 一是因为非对称加密算法的加密速度，远小于对称加密速度。直接对原文进行签名，消耗较大；而是因为非对称加密，对加密信息的长度，有着严格的要求，只能用于少量数据的加密。比如，RSA加密算法，要求加密的数据不得大于53个字节。
> )
>
> **验证过程：** 收方验证签名，即用发方公钥解密数字签名，得出数字摘要；收方将原文采用同样哈希算法又得一新的数字摘要，将两个数字摘要进行比较，如果二者匹配，说明经数字签名的电子文件传输成功。
>
> **用于防止消息篡改的场景**
> Alice通过信道发给Bob一个文件（一份信息），Bob如何获知所收到的文件即为Alice发出的原始版本？
> Alice可以先对文件内容进行摘要，然后用自己的私钥对摘要进行加密（签名），之后同时将文件和签名都发给Bob。
> Bob收到文件和签名后，用Alice的公钥来解密签名，得到数字摘要，与收到文件进行摘要后的结果进行比对。
> 如果一致，说明该文件确实是Alice发过来的（别人无法拥有Alice的私钥），并且文件内容没有被修改过（摘要结果一致）



**数字签名与消息验证码的区别**

消息验证码是**基于对称加密**，可以用于**对消息完整性（integrity）**进行保护。通信双方需要提前共享的对称密钥和Hash算法。

数字签名是基于**非对称加密，**MAC不仅能够保证完整性，还能够保证真实性。双方不需要共享密钥，私钥仅仅需要被一方掌握。



## **2、数字证书**

**公钥可能被篡改的危机**

对于非对称加密算法和数字签名来说，很重要的一点就是**公钥的分发。**

理论上任何人可以公开获取到对方的公钥。然而这个公钥有没有可能是伪造的呢？传输过程中有没有可能被篡改掉呢？一旦公钥自身出了问题，则整个建立在其上的安全体系的安全性将不复存在。

**数字证书机制正是为了解决这个问题**，它就像日常生活中的一个证书一样，可以证明所记录信息的合法性。

比如证明某个公钥是某个实体（如组织或个人）的，并且确保一旦内容被篡改，就能被探测出来，从而实现对用户公钥的安全分发。我们谈论数字证书的时候，可以从以下几个方面讨论：

![img](https://pic2.zhimg.com/80/v2-c1d7534e0b3b94f8b2cd75a861bf0101_720w.jpg)数字证书基本情况

**证书的分类**

根据所保护公钥的用途，可以分为加密数字证书（Encryption Certificate）和签名验证数字证书（Signature Certificate）。

**加密数字证书**用于**保护**用于加密信息的**公钥**；

**签名验证数字证书**则**保护**用于进行解密签名进行身份验证的**公钥**。

两种类型的公钥也可以同时放在同一证书中。



**证书颁发机构**

一般情况下，证书需要由证书认证机构（Certification Authority，CA）来进行签发和背书。权威的证书认证机构包括DigiCert、GlobalSign、VeriSign等。用户也可以自行搭建本地CA系统，在私有网络中进行使用。

从上面我们可以得知，**证书作为公钥信任的基础。**

那么，怎么用证书来实现公钥的安全分发呢？

在HyperLedger-Fabric中，使用的是**PKI体系**来保证的。



**关于数字证书的格式：**

一般来说，一个数字证书内容可能包括基本数据（版本、序列号）、所签名对象信息（签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥）、CA的数字签名，等等。

目前使用最广泛的标准为ITU和ISO联合制定的X.509的v3版本规范（RFC 5280）。

X.509规范中一般推荐使用**PEM（Privacy Enhanced Mail）格式来存储证书相关的文件**。

- **证书文件的文件名后缀一般为.crt或.cer**，
- **对应私钥文件的文件名后缀一般为.key，**
- **证书请求文件的文件名后缀为.csr。**
- **有时候也统一用.pem作为文件名后缀。**

PEM格式采用文本方式进行存储，一般包括首尾标记和内容块，内容块采用Base64进行编码。此外，还有DER（Distinguished Encoding Rules）格式，是采用二进制对证书进行保存，可以与PEM格式互相转换



## **3、PKI体系**

**简介**

在非对称加密中，**公钥可以通过证书机制来进行保护**，但证书的生成、分发、撤销等过程并没有在X.509规范中进行定义。

在实际工程中，安全地管理和分发证书可以遵循PKI（Public Key Infrastructure）体系来完成。

**PKI体系核心解决的是证书生命周期相关的认证和管理问题**，在现代密码学应用领域处于十分基础和重要的地位。

在HyperLedger-Fabric区块链系统中，就是用PKI体系来对证书进行管理的。

接下来，将从以下几个方面来介绍PKI体系：

![img](https://pic1.zhimg.com/80/v2-695e07d8d9a116dfed83087687365c80_720w.jpg)PKI体系

**PKI基本组件**

一般情况下，PKI至少包括如下核心组件：

> **·CA**（Certification Authority）**证书颁发机构**：负责证书的颁发和作废，接收来自RA的请求，是最核心的部分；
> **·RA**（Registration Authority）**用户登记机构**：对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给CA；
> **·证书数据库**：存放证书，多采用X.500系列标准格式。可以配合LDAP目录服务管理用户信息。

其中，**CA**是最核心的组件，主要完成对证书信息的维护。

**PKI操作流程**

常见的操作流程为：

> \1. 用户通过RA登记申请证书，提供身份和认证信息等；
> \2. RA审核完成后发给CA；
> \3. CA审核后完成证书的制造，颁发给用户。用户如果需要撤销证书则需要再次向CA发出申请。



**证书的签发**

**CA对用户签发证书实际上是对某个用户公钥，使用CA的私钥对其进行签名。这样任何人都可以用CA的公钥对该证书进行合法性验证。验证成功则认可该证书中所提供的用户公钥内容，实现用户公钥的安全分发。**

用户证书的签发可以有两种方式。

> 一种是由CA直接来生成证书（内含公钥）和对应的私钥发给用户；
> 另一种是由用户自己生成公钥和私钥，然后由CA来对公钥内容进行签名。

后者情况下，用户一般会首先自行生成一个私钥和证书申请文件（Certificate Signing Request，即csr文件），该文件中包括了用户对应的公钥和一些基本信息，如通用名（common name，即cn）、组织信息、地理位置等。

CA只需要对证书请求文件进行签名，生成证书文件，颁发给用户即可。整个过程中，用户可以保持私钥信息的私密性，不会被其他方获知（包括CA方）。



**证书的撤销**

证书超出有效期后会作废，用户也可以主动向CA申请撤销某证书文件。

由于CA无法强制收回已经颁发出去的数字证书，因此为了实现证书的作废，往往还需要维护一个**撤销证书列表**（Certificate Revocation List，CRL），用于记录已经撤销的证书序号。

因此，通常情况下，当第三方对某个证书进行验证时，需要首先检查该证书是否在撤销列表中。如果存在，则该证书无法通过验证。如果不在，则继续进行后续的证书验证过程。

------

## **4、Merkle树结构**

**简介**

Merkle（默克尔）树，又叫哈希树，是一种典型的二叉树结构，由一个根节点、一组中间节点和一组叶节点组成。在区块链系统出现之前，广泛用于文件系统和P2P系统中。其基本结构如下图所示：

![img](https://pic3.zhimg.com/80/v2-6f49913dc00c959ff2c21c39b99db3f2_720w.jpg)Merkle树结构

其主要特点为：

> **· 最下面的叶节点包含存储数据或其哈希值；**
> **· 非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。**

进一步地，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点内容的哈希值。

默克尔树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味树根的值实际上代表了对底层所有数据的“数字摘要”。



**Merkle树应用场景**

目前，默克尔树的典型应用场景有很多，下面分别介绍。

**1.快速比较大量数据**

对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着两组数据必然相同。否则，必然存在不同。

由于Hash计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。

**2.快速定位修改**

例如上图Merkle树结构图中。如果D1中数据被修改，会影响到N1、N4和Root。

因此，一旦发现某个节点如Root的数值发生变化，沿着Root→N4→N1，最多通过O（lgn）时间即可快速定位到实际发生改变的数据块D1。

------

## **5、布隆过滤器**

**简介**

布隆过滤器是一种基于Hash的高效查找结构，能够快速（常数时间内）回答“某个元素是否在一个集合内”的问题。

如下图所示，是一个简单的布隆过滤器结构：

![img](https://pic2.zhimg.com/80/v2-53e4c4607429322ce9f7563d53f000c5_720w.jpg)布隆过滤器示意图

布隆过滤器（Bloom Filter）的核心实现是**一个超大的位数组和几个哈希函数**。假设位数组的长度为m，哈希函数的个数为k：

以上图为例，具体的操作流程：

> 假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。
> 对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。
>
> 查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。
>
> 可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。

布隆过滤器因为其高效性大量应用于网络和安全领域，例如信息检索（BigTable和HBase）、垃圾邮件规则、注册管理等。



**布隆过滤器的应用场景**

- **1.基于Hash的快速查找**

Hash函数的一个常见应用就是**基于Hash的快速查找算法。**

**基于哈希的快速查找，实际上是一种基于内容的编址方式。**

Hash可以将任意内容映射到一个固定长度的字符串，而且不同内容映射到相同串的概率很低。因此，这就构成了一个很好的“内容→索引”的生成关系。

试想，如果给定一个内容和存储数组，通过构造Hash函数，让映射后的Hash值总不超过数组的大小，则可以实现快速的基于内容的查找。

例如，内容“hello world”的Hash值如果是“100”，则存放到数组的第100个单元上去。如果需要快速查找任意内容，如“hello world”字符串是否在存储系统中，只需要将其在常数时间内计算Hash值，并用Hash值查看系统中对应元素即可。该系统“完美地”实现了常数时间内的查找。

然而，令人遗憾的是，当映射后的值限制在一定范围（如总数组的大小）内时，会发现Hash冲突的概率会变高，而且范围越小，冲突概率越大。很多时候，存储系统的大小又不能无限扩展，这就造成算法效率的下降。

为了提高空间利用率，后来人们基于Hash算法的思想设计出了布隆过滤器结构。

**2.更高效的布隆过滤器**

布隆过滤器采用了多个Hash函数来提高空间利用率。对同一个给定输入来说，多个Hash函数计算出多个地址，分别在位串的这些地址上标记为1。进行查找时，进行同样的计算过程，并查看对应元素，如果都为1，则说明较大概率是存在该输入。如下图所示：

![img](https://pic4.zhimg.com/80/v2-ba12672c7f25960e6c7484e61107d09f_720w.jpg)布隆过滤器

布隆过滤器相对单个Hash算法查找，大大提高了空间利用率，可以使用较少的空间来表示较大集合的存在关系。

------

## **6、同态加密**

**简介**

同态加密是一种加密形式，它允许人们对**密文进行特定的代数运算**得到仍然是**加密的结果**，将运算后的数据进行解密，其解密所得到的结果与对明文进行同样的运算结果一样。

什么意思呢？

一般的加密方案关注的都是数据存储安全。

即，我要给其他人发个加密的东西，或者要在计算机或者其他服务器上存一个东西，我要对数据进行加密后在发送或者存储。没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正确解密，得到原始的内容。

我们注意到，**这个过程中**

**用户是不能对加密结果做任何操作的！**

**用户是不能对加密结果做任何操作的！**

**用户是不能对加密结果做任何操作的！**



只能进行存储、传输。**对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。**

**但是，**

同态加密提供了一种**对加密数据进行处理，加密数据进行处理，加密数据进行处理的功能**。

也就是说，**其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。**

**举例来说：**

> A和B两个用户。A需要把自己的数据给B处理。
> 有两种方式：
> 方式一：A把自己的数据进行加密，发送给B。B将数据解密后，对数据进行处理，然后得到目标结果Result。最后把处理后的结果发送给A。
> 方式二： A把自己的数据进行加密，发送给B。B直接对加密的数据，进行处理，然后得到处理的结果Result*.A收到Result*之后，通过私钥解密Result*，最终得到Result。
>
> **方式二用到的方法，就是同态加密。**
> 在方式二的方式中，B完成了对A数据的处理目的，并且保证了A用户的隐私！

**意义**

换言之，这项技术令人们可以在加密的数据中进行诸如检索、比较等操作，得出正确的结果，而在整个处理过程中无需对数据进行解密。其意义在于，真正从根本上解决将数据及其操作委托给第三方时的保密问题，例如对于各种云计算的应用。

------

## **三、总结**

综上所述，本文的所有内容都是基于哈希函数和加解密算法展开的。

消息认证码和数字签名，Merkle树，布隆过滤器等都是基于Hash函数的应用。

数字证书，PKI体系，则是非对称密码体系安全性的保障。有了对这些基础知识的了解，我们会更容易理解区块链是怎样实现信息安全的。