# UTXO

22018.06.03 16:30:47字数 1,679阅读 17,899

## 什么是UTXO

在比特币钱包当中，我们通常能够看到账户余额，然而在中本聪设计的比特币系统中，并没有余额这个概念。“比特币余额”是由比特币钱包应用派生出来的产物。中本聪发明了UTXO交易模型，并将其应用到比特币当中。

**UTXO（Unspent Transaction Outputs）是未花费的交易输出，它是比特币交易生成及验证的一个核心概念。交易构成了一组链式结构，所有合法的比特币交易都可以追溯到前向一个或多个交易的输出，这些链条的源头都是挖矿奖励，末尾则是当前未花费的交易输出。**

## 基于账户的交易

我们先看下传统的交易是如何进行的：我们设计一个支付系统，给张三一个账户，里面有余额100 元，李四有一个账户，里面有余额50元。当张三要付给李四20元时，做以下操作：

\1. 检查张三账户余额是否充足，如果不足20元就终止交易，向张三报“余额不足”

\2. 在张三账户里减去20元（假设零手续费）

\3. 在李四账户里增加20元

现在的银行也好、信用卡也好、证券交易系统也好，互联网第三方支付系统也好，其核心都是基于账户（account based）的设计，由关系数据库支撑。

## 基于UTXO的交易

要理解UTXO，最简单的办法就是把一枚比特币从诞生到在商海中沉浮的经历描述一下。我们假设一个这样的场景：张三挖到12.5 枚比特币。过了几天，他把其中 2.5 枚支付给李四。又过了几天，他和李四各出资 2.5 比特币凑成 5 比特币付给王五。

比特币的区块链账本里记录的是一笔又一笔的交易。

每笔交易都有若干交易输入，也就是资金来源，也都有若干笔交易输出，也就是资金去向。一般来说，每一笔交易都要花费（spend）一笔输入，产生一笔输出，而其所产生的输出，就是“未花费过的交易输出”，也就是 UTXO。

**比特币交易遵守几个规则：**

**第一，除了 coinbase交易之外，所有的资金来源都必须来自前面某一个或者几个交易的 UTXO，就像接水管一样，一个接一个，此出彼入，此入彼出，生生不息，钱就在交易之间流动起来了。**

**第二，任何一笔交易的交易输入总量必须等于交易输出总量，等式两边必须配平。**

![img](https://upload-images.jianshu.io/upload_images/11974257-d2d649b57aff1724?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

上图第一个交易#1001 号交易是 coinbase 交易。比特币是矿工挖出来的。当一个矿机费尽九牛二虎之力找到一个合格的区块之后，它就获得一个特权，能够创造一个 coinbase 交易，在其中放入一笔新钱，并且在交易输出的收款人地址一栏，堂堂正正的写上自己的地址。假设这笔比特币的数额为12.5 枚，这个coinbase 交易随着张三挖出来的区块被各个节点接受，经过六个确认以后永远的烙印在历史中。

过了几天，张三打算付 2.5 个比特币给李四，张三就发起#2001号交易，这个交易的资金来源项写着“#1001(1)”，也就是 #1001 号交易——张三挖出矿的那个 coinbase 交易——的第一项 UTXO。然后在本交易的交易输出 UTXO 项中，把2.5个比特币的收款人地址设为李四的地址。

请注意，这一笔交易必须将前面产生那一项 12.5 个比特币的输出项全部消耗，而由于张三只打算付给李四 2.5 个比特币，为了要消耗剩下的10比特币，他只好把剩余的那 10 个比特币支付给自己，这样才能符合输入与输出配平的规则。

再过几天，张三和李四打算AA制合起来给王五付 5 枚比特币。那么张三或李四发起 #3001 号交易，在交易输入部分，有两个资金来源，分别是#2001(1) 和 #2001(2)，代表第 #2001 号交易的第 (1) 和第 (2) 项 UTXO。然后在这个交易的输出部分里如法炮制，给王五5比特币，把张三剩下的 7.5 比特币发还给自己。以后王五若要再花他这5比特币，就必须在他的交易里注明资金的来源是 #3001(1)。

所以，其实并没有什么比特币，只有UTXO。当我们说张三拥有 10 枚比特币的时候，我实际上是说，当前区块链账本中，有若干笔交易的 UTXO 项收款人写的是张三的地址，而这些 UTXO 项的数额总和是 10。而**我们在比特币钱包中所看到的账户余额，实际上是钱包通过扫描区块链并聚合所有属于该用户的UTXO计算得来的。**

## 两种交易方式对比

1.UTXO只需要看最后一次交易，而账户系统要看历史全数据后所有的增减操作全部加起来才能获得正确的余额，两者效率差异随着时间推移会越来越大；

2.UTXO未来可以裁剪历史老数据，而账户系统则不能丢弃老数据，前者区块链可以控制住整体大小，而后者只能持续膨胀。

## 一点思考

比特币规定每一笔新的交易的输入必须是某笔交易未花费的输出，每一笔输入同时也需要上一笔输出所对应的私钥进行签名，并且每个比特币的节点都会存储当前整个区块链上的UTXO，整个网络上的节点通过UTXO及签名算法来验证新交易。



# UTXO详解

刚刚接触比特币的朋友经常会遇到这个词，官方解释是未经使用的交易输出。只从这个定义上，你能明白是什么意思吗？反正我是困惑了很久。

我们常规的理解是，账户，余额，支出，收入。比如，银行账户，我们有1万元，收入1万，则余额为2万，支出5000，余额为1万5000元。但比特币里实际上是没有账户和余额的概念的。只有一个概念叫utxo，实际上就是你能够支配的，并且还没有被使用的btc，这些btc作为一个整体（无论比特币的数值是多少，都做为一个整体）保存在比特币系统网络里，而且这个utxo能用且只能用一次。

我们可以把utxo类比成支票。支票的数额可以是1元或者1亿元。utxo的数额可以是1聪btc，也可以是1万个btc，但都是一个整体，不可分割。

假设A有一张支票，价值1万元，需要付款给B5000元，那么，B会得到一张5000元的支票，交易费用是100元，作为一张支票给第三方，A自己得到一张支票，价值4900元。原来的1万支票已经使用过，不能再次使用，A,B,第三方分别得到一张新的支票，都是未被使用过的。三个人分别对这三张支票有使用权。

同样的，A有一个utxo，价值1万个btc，需要付款给B5000个btc，那么B会得到一个utxo（价值5000个btc），矿工得到一个utxo（矿工费1btc），A也会得到一个utxo（价值4999btc）。原来的含1万个btc的utxo被系统标记过使用过，任何人不能在使用。而A,B,矿工分别得到一个utxo。他们分别对自己名下的utxo有使用权。

如下图所示，A有一个UTXO_1，价值1万btc，给B5000个btc以后，B得到一个utxo_2,价值5000个btc，矿工得到一个utxo_3,价值1个btc，A自己得到一个utxo_4,价值4999btc。原来的utxo_1,被系统标记未使用过。不能再次使用，即不能被双花。以此类推，当A在给C1000个btc时，C得到一个utxo_5,价值1000个btc，矿工得到一个utxo_6,价值0.2btc，A得到一个utxo_7,价值3999.8btc。

![img](https:////upload-images.jianshu.io/upload_images/4062538-e8a90af33184549b.png?imageMogr2/auto-orient/strip|imageView2/2/w/590/format/webp)

此时，系统中，未经使用的交易输出（utxo）包括：

B的utxo_2（价值5000btc），

矿工的utxo_3(价值1btc)和uxto_6(价值0.2btc)，

C的utxo_5(价值1000btc)

A的utxo_7(价值3999.8btc)

原来的utxo_1,utxo_4，是已经被使用过的交易输出，不能再次使用。

因此，在比特币的系统中，并没有账户和余额的概念。系统中只有utxo，谁有这个utxo的密钥和签名，谁就拥有这个utxo。

https://steemit.com/utxo/@electroman/utxo



作者：electroman
链接：https://www.jianshu.com/p/7a6ec46cf84b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





# 比特币交易流程总结

​    摘要：比特币是一个分布式的点对点网络系统。它被设计成为一种完全通过点对点技术实现的电子现金系统，可以不通过中间任何的金融机构直接由一方发起并支付给另外一方。比特币系统基本单位是UTXO(未经使用的一个交易输出)，账户是通过脚本来进行金额的锁定，要提供一个包含用户私钥的解锁脚本来解锁输出。比特币系统通过PoW(工作量证明)生产区块已证明交易的合法性，难度会随系统的算力进行相应的改变，平均十分钟出一块区块。基于与上一个区块生成的随机散列来生成新的散列提供给下一个区块，形成了多路链式结构（会出现分叉），有效避免了系统的恶意攻击（51%攻击）。
​    主要是对知识的总结，理解会有偏差。从小明向小红转钱来进行知识的整体的梳理。

## 引子

小明一天和朋友出去游玩，在路上结识朋友小红，两人相聊甚欢，临走之际小明对小红说："我俩都喜欢区块链，要不我送你 1w 区块链做一个纪念一下，把你的地址给我一个"。我们占且不说小明那来的这么多btc，也不讲私钥通过椭圆曲线相乘变成公钥，公钥双哈希再Base58Check编码形成比特币地址，最有可能是原因就是小明拿着锄头从电脑里挖出来的。小红刚和小明认识没有多久又怎么好意思要小明的东西，但耐不住小明一片心意，盛情难却啊。小红只好会回答:"我俩认识时间不长，无需如此，要不折个现，给个零头就行，我的支付宝账号是xxxx?"。小明一脸生气?，“这个太麻烦了，我还是转给博主吧”。

![img](https://img-blog.csdn.net/20180410105729901)

## 交易

当小明转给小红的时候，当一个交易诞生的那一刻，比特币交易会被一个或者多个签名加密，这些签名标志着对该交易指向的比特币资金的使用许可。接下来，比特币交易被广播到比特币网络中。任何一笔交易都是一个含有输入值和输出值的数据结构，该数据结构植入了将一笔资金从初始点（输入值）转移至目标地址（输出值）的代码信息。 当这笔交易被网络中的一个节点认可时，网络节点会把这个交易继续广播到其他相连接的节点，发起着会收到一个交易有效接受的消息；当这笔交易未被认可时，节点会拒绝交易并返回交易拒绝的消息。

如果仅仅到这里这和中性化支付系统是差不多了，中心化系统此时会在系统中记录用户传过来的消息进行消息处理记录，返回客户端交易完成就行了。中心化的系统这里解决的是两个陌生交易者的信任问题，它以自己作为信任担保。现在的系统也是分布式的框架，中心化的分布式系统解决的是大流量的问题，因为系统是中心化的所以请求和事物处理也过于集中，就会有事物过于集中。单点是无法处理怎么大流量。不管是业务的拆分部署，数据库的分库分表，系统的降级限流，软负载均衡的搭建都是以更小的代价来处理更多的事物请求。我之前感觉这是一个全新的技术，现在理解的比特币它牛逼在，它提供了一个全新的解决方案。


交易是将钱从交易输入移至输出。输入是指钱币的来源，通常是之前一笔交易的输出。交易的输出则是通过关联一个密钥的方式将钱赋予一个新的所有者。这样随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链。因为是链式的存储结构所以就有了溯源的功能。

![img](https://img-blog.csdn.net/20180410110450367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdtaW4yMDE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


每一笔的交易都是通过比特币交易脚本来实现的，一个锁定脚本和一个解锁脚本。锁定脚本是一个放在一个输出值上的“障碍”，同时它明确了今后花费这笔输出的条件。由于锁定脚本往往含有一个公钥（即比特币地址），解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，同时它将允许输出被消费。

![img](https://img-blog.csdn.net/20180410110700746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdtaW4yMDE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


多笔交易汇聚在一起就是一个账单(区块)，虚拟货币是如何被系统认可，认为这笔交易是成功的呢，比特币系统的参与者共同维护了一个公共的账本，也就是一个公共的数据结构，每一个参与者都会共下载一个完整的账本数据，当一个参与者完成了区块的计算，会把这个计算结果全网公布，其他节点得到这个结果后会验证，验证成功之后会把这个写入自己的区块中表示认可，并立刻进行下一个区块的计算。

交易是被写入区块之中，但使用区块来进行校验会是数量过大，区块头中的merkle结构就是为了快速校验和查找。区块头还被用来与前一区块相连接。矿工挖矿也是也是通过改变 Nonce来计算区块的hash值，计算出来的值小于难度目标，区块就是可以被写入帐本之中，随之系统会奖励矿工一笔挖矿的费用。这笔费用是很特殊的，他没有输入来源，称为创币交易，不包含“解锁脚本“(又称作 scriptSig)字段，字段被Coinbase所代替。区块难度会随着系统算力来进行相应的改变。这个就比特币系统中的PoW(工作量证明)。因为所有区块头都与前一块区块相连接所以想要修改交易必须要重新计算区块之后的的所有区块，代价过于庞大几乎是不可能的，所以说区块链是不可以被篡改的。理论上来讲，一个人拥有51%的算力，他就可以随意修改比特币系统了，但是他拥有这么大的算力之后，他完全可以用算力来进行挖矿牟利不需要用这么大的力气来进行数据修改。51%攻击就这样不太可能发生。

 区块数据结构：

![img](https://img-blog.csdn.net/20180410110914443?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdtaW4yMDE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

区块头数据结构：

![img](https://img-blog.csdn.net/20180410111012567)

当此时这笔交易已经算是完成了，但是系统可能会出现分叉所以建议的时候当交易被写入帐本之后的六个区块后才算正式确认交易成功。

## 双重支付

比特币是一个分布式的点对点网络系统。它被设计成为一种完全通过点对点技术实现的电子现金系统。就是因为上面的特证。必然会出现分布式系统问题，就会引入拜占庭将军问题，之前一直以为这是区块链系统问题，后来慢慢了解这个是分布式系统的问题。分布式系统中就会存在一致性问题，信息传输延迟，消息顺序问题。基本会把并行数据改变为串形处理。使用CAP/BASE原则（了解一点，但不总结就忘记，以后总结一下）。

注：拜占庭将军问题是一个模型，它表示的是 信道可信下的一致性问题。对应的蓝军问题模型是在一致性相同下信道不可信问题。通过了TCP/IP 协议解决。

因为比特币是虚拟货币就会有双重支付问题。因为是在一个分布式系统之中,就会出现系统中有两个矿工同时找到了符合要求的Nonce的随机字符串他们会同时广播到系统中，离他们相近的就会验证和同意这个区块的产生，这个时候体统就出现了分叉.此时系统会分成A区和B区他们会同时进行下一个区块的计算。之后的验证大家都会找最长的作为主链来进行计算链来进行计算

![img](https://img-blog.csdn.net/20180410111253818)

黑色表示当前账簿主干。此时，可以随便选择一个页作为当前主分支，例如选择A：

![img](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/10.png)


此时如果有一个新的账簿页是基于A的，那么这个主干就延续下去：

![img](https://img-blog.csdn.net/20180410111434738)


如果这个主干一直这么延续下去，表示大家基本都以A为主干，B就会被遗忘。但是也有可能忽然B变成更长了：

![img](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/12.png)

那么我们就需要将B分支作为当前主干，基于这个分支进行后续工作。

![img](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/13.png)

从局部来看，虽然在某一时刻各个小组的账簿主干可能存在不一致，但大方向是一致的，那些偶尔由于不同步产生的小分支，会很快被淹没在历史中。


双花问题就是基于这个点来实现的，当攻击者向一个用户A支付了一笔钱，用户收到了区块确认之后进行交易，但是攻击者同时又用这笔钱想另一个用户B支付同一笔钱，故意造成分叉来使上一笔交易失效。比特币是通过PoW来解决的，有这个算力去攻击还不如去挖矿赚钱。避免了51%攻击。


第一步，攻击者准备从受害者A手里买10比特币的黄金，他签署交易单给受害者A，转10个比特币给受害者A。

![img](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/14.png)

第二步，这笔交易在最新的账簿页中被确认，并被各个挖矿小组公告出来。受害人A看到公告，确认比特币到账，给了攻击者10个比特币等值的黄金。


第三步，攻击者找到账簿，从包含刚才交易的账簿页的前一页做出一个分支，生成更多的账单页，超过刚才的分支。由于此时刚才攻击者制造的分支变成了主干分支，而包含受害者A得到钱的分支变成了旁支，因此挖矿组织不再承认刚才的转账，受害者A得到的10比特币被取消了。

![img](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/16.png)

第四步，攻击者可以再次签署交易单，将同一笔钱支付给受害者B。受害者B确认钱到账后，支付给攻击者等值黄金。

![img](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/17.png)

至此，攻击者将10个比特币花了两次，从两名受害者那里各购得等值黄金。攻击者还可以如法炮制，取消与受害者B的转账，将同一笔钱再支付给其他人……

## 硬分叉和软分叉

软分叉是通过数据结构的协议进行改变，节点可以不进行继续升级，但产生的区块会不合法。

硬分叉是永久性分叉，修改了相应的结构，需要升级节点，产生了永久的分歧。

参看：什么是硬分叉，什么是软分叉，什么是共识？


参考：

1.<<精通比特币>>

2.拜占庭将军问题深入探讨

3.什么是硬分叉，什么是软分叉，什么是共识？

4一个故事告诉你比特币的原理及运作机制

————————————————
版权声明：本文为CSDN博主「淘沙0820」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhangmin2016/article/details/79878526