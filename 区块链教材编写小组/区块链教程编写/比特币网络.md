# 比特币网络-点对点的网络架构

比特币采用了基于互联网的点对点（P2P：peer-to-peer）分布式网络架构。
 比特币网络可以认为是按照比特币P2P协议运行的一系列节点的集合。
 本文来分析下比特币网络，了解它跟传统中心化网络的区别，以及比特币网络是如何发现相邻节点的。

## 中心化网络

为了更好的理解P2P网络，我们先来看看传统的中心化模型：



![img](https:////upload-images.jianshu.io/upload_images/11095853-e155757317989d63.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



这是一种典型的星型（“中心化”）结构，我们常见B/S及C/S网络架构就是这种模型，C1 、C2 、C3等之间没法直接的连接，C节点如果要连接必须要通过中心化S节点做为桥梁。
 中心化节点充当服务者、中介作用，比如我们没有办法把资金直接从一个人转移给另一个人，必须通过银行这个中介。

## P2P网络

P2P网络是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点，每个网络节点以扁平（flat）的拓扑结构相互连通。



![img](https:////upload-images.jianshu.io/upload_images/11095853-cc3c649a3752a7bd.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



对比中心化网络，在P2P网络中不存在任何服务端（server）、中央化的服务。
 P2P网络的节点之间交互连接、协同，每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务，每个节点即是服务端又是客户端。
 P2P网络模型除应用于比特币网络，使用广泛的BT下载就是基于P2P网络。

P2P网络不仅仅去除了中心化带来的风险（中心化可能作恶），还可以提高传输的效率。（中心化网络当能也有优点）

## 如何发现节点

既然每个网络节点都是平等的（是指在网络层面上节点是平等的，但各节点在功能上可以有不同的分工, 如钱包节点、挖矿节点等），不存在任何“特殊”中心节点，那么当新的网络节点启动后，它是如何跟其他的节点建立连接，从而加入到比特币网络呢？

在中心化网络中，新加入的节点只要连接“特殊”的中心节点就可以加入网络。

为了能够加入到比特币网络，比特币客户端会做一下几件事情：

- 节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。
- 节点会在失去已有连接时尝试发现新节点。
- 当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。
- 新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。
- 在节点启动时，可以给节点指定一个正活跃节点IP, 如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。

## 节点通信简述

比特币节点通常采用TCP协议、使用8333端口与相邻节点建立连接, 建立连接时也会有认证“握手”的通信过程，用来确定协议版本，软件版本，节点IP，区块高度等。

当节点连接到相邻节点后，接着就开始跟相邻节点同步区块链数据（轻量级钱包应用其实不会同步所有区块数据），节点们会交换一个getblocks消息，它包含本地区块链最顶端的哈希值。如果某个节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，就说其自身的本地区块链比其他节点的区块链更长，并告诉其他节点需要补充区块，其他节点发送getdata消息来请求区块，验证后更新到本地区块链中。



作者：区块链技术布道者
链接：https://www.jianshu.com/p/0a2be47468cc
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 比特币网络

## P2P网络

无中心化的身份对等网络是比特币网络的基础。具有如下特点：
 1、网络拓扑结构：没有中心节点，节点之间全互联。
 2、节点身份：所有节点身份地位同等。既是服务提供者，又是服务消费者。
 3、扩展比特币网络（extended bitcoin network）：指代所有包含比特币P2P协议、矿池挖矿协议、Stratum协议以及其他连接比特币系统组件相关协议的整体网络结构。

![img](https:////upload-images.jianshu.io/upload_images/1785959-e21283d15e9553eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



## 节点类型分工

节点之间还是有分工的。每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。
 1、比特币网络核心客户端（Bitcoin Core）包括这4个功能：钱包、矿工、完整区块链、网络路由节点。
 2、全节点这个全指的是拥有完整的区块链副本。全节点可以不借助其他节点就可以完成校验交易。
 3、轻量级节点：只保留一部分区块链交易（与自己相关的区块链），采用“简易支付验证（SPV）”的方式来完成交易验证。
 挖矿节点可以是全节点，也可以是SPV节点。



![img](https:////upload-images.jianshu.io/upload_images/1785959-bee5cc05629c568f.png?imageMogr2/auto-orient/strip|imageView2/2/w/654/format/webp)

节点类型分工

## 网络发现

1、新节点
 新加入的节点，需要与已经存在的节点通信，就需要遵循基本的规则：这是TCP/IP网络，端口号8333与已知的对等节点建立连接。
 接下来就要开始握手。
 2、握手消息
 这里约定握手使用的语言和沟通内容。
 ▷ PROTOCOL_VERSION
 常量，定义了客户端所“说出”的比特币P2P协议所采用的版本（例如：70002）。
 ▷ nLocalServices
 一组该节点支持的本地服务列表，当前仅支持NODE_NETWORK
 ▷ nTime
 当前时间
 ▷ addrYou
 当前节点可见的远程节点的IP地址
 ▷ addrMe
 本地节点所发现的本机IP地址
 ▷ subver
 指示当前节点运行的软件类型的子版本号（例如：”/Satoshi:0.9.2.1/”）
 ▷ BaseHeight
 当前节点区块链的区块高度
 3、第一次握手
 新节点当中会有一个长期稳定运行的节点名单（这些叫seed node）。或者也可以启动时指定一个dns种子节点。
 新节点启动，向已经存在的节点发送version握手消息。对方反馈verack，有其他特别需求时也会返回verision。

![img](https:////upload-images.jianshu.io/upload_images/1785959-44819007264baa3b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1014/format/webp)

第一次握手



4、第二次握手
 第一次握手后，新节点把自己的IP地址给对方（addr），对方得到后发送到整个网络。新节点继续发出想要得到对方所知道的所有IP地址的要求（getaddr），对方节点返回消息后，新节点从中寻找距离自己最近的对方节点。这样将新节点就加入网络。
 这个节点还有其他工作，当自己断网重连后寻找新节点，其他节点断网重连后提供帮助。



![img](https:////upload-images.jianshu.io/upload_images/1785959-7be36af6746dcd42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1057/format/webp)

第二次握手

## 如果新节点是全节点

新节点准备成为全节点，那么需要一系列的步骤完成同步过程。
 新节点一般只有创世区块（0号区块），它发送version消息（BaseHeight字段标示了一个节点当前的区块链高度（区块数量）），双方握手后会交换一个getblocks消息，就知道各有多少个区块。老节点发送inv消息说你还差多少个（哈希一下）。新节点说getdata，你给我吧。老节点给新节点，新节点验证哈希，说：对，这就是我缺少的。
 需要说明的是，为减轻网络负担，inv消息一般一次只包括500个区块。也就说上述消息发送，区块同步是在新节点与多个老节点之间逐一依次进行的。这个过程一直重复，直到同步完成。



![img](https:////upload-images.jianshu.io/upload_images/1785959-70c61e32dbd474cd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1089/format/webp)

区块同步过程

## 轻量型节点SPV节点

> SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000。SPV节点不能构建所有可用于消费的UTXO的全貌，这是由于它们并不知道网络上所有交易的完整信息。
>  举例，全节点就像拥有这个世界完整地图的游客，虽然携带不方便，但是查起来容易，SPV节点就像一个游客只有一张简易地图，只有 城市名称，你去往哪个城市，得从出发地开始一路走着问着才行。
>
> ![img](https:////upload-images.jianshu.io/upload_images/1785959-ef0cc5a2c4a54b0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1033/format/webp)
>
> SPV节点同步区块头
>
> 也就是，全节点验证交易的方式是沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易，SPV节点是先验证区块形成的链，通过检查在其上面的区块将它压在下面的深度，再把区块链和交易关联起来来验证交易。再具体一点，SPV节点会通过请求merkle路径证明以及验证区块链中的工作量证明，来证实交易的存在性。但是它的最大问题是可以验证交易的存在，但是对于不存在的交易却无能为力，因为它不像全节点维护这完整的区块链。对此，就有可能发生漏洞攻击。
>  由于SPV节点需要读取特定交易从而选择性地验证交易，这样就又产生了隐私风险。与全区块链节点收集每一个区块内的全部交易所不同的是，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。解决的方法是过滤器。

## Bloom过滤器

> Bloom过滤器是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法。它能让用户在有效搜索关键词的同时保护他们的隐私。在SPV节点里，这一方法被用来向对等节点发送交易信息查询请求，同时交易地址不会被暴露。

就像之前的游客，当他到处询问“教堂街32号”的时候也就泄露了自己的目的地。他可以说：我要去带有“堂”字的街道，或者“教”字开头的街道。
 具体步骤：
 1、SPV节点会初始化一个不会匹配任何关键词的“空白”Bloom过滤器。
 2、SPV节点会创建一个包含钱包中所有地址信息的列表，并创建一个与每个地址相对应的交易输出相匹配的搜索模式。
 3、SPV节点会把每一个搜索模式添加至Bloom过滤器里，这样只要关键词出现在交易中就能够被过滤器识别出来。
 4、对等节点会用收到的Bloom过滤器来匹配传送至SPV节点的交易。
 具体过程：

> Bloom过滤器数组里的每一个数的初始值为零。关键词被加到Bloom过滤器中之前，会依次通过每一个哈希函数运算一次。该输入经第一个哈希函数运算后得到了一个在1和N之间的数，它在该数组（编号依次为1至N）中所对应的位被置为1，从而把哈希函数的输出记录下来。接着再进行下一个哈希函数的运算，把另外一位置为1；以此类推。当全部M个哈希函数都运算过之后，一共有M个位的值从0变成了1，这个关键词也被“记录”在了Bloom过滤器里。

![img](https:////upload-images.jianshu.io/upload_images/1785959-9c78418f0bd8a5bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1161/format/webp)

向简易Bloom过滤器中增加关键词“A”



再向简易Bloom过滤器中增加关键词“B”，就是重复上述过程。不同的是如果该位的0在增加A时已经变成1，那么再次遇到该位就保留1。这样增加越多，准确度将降低了。

> 当过滤器建好之后，对等节点将每个交易的输出值代入过滤器中验证。那些匹配的交易会被传送回SPV节点。为回应来自SPV节点的getdata信息，对等节点会发出一条只含有和过滤器匹配的区块的区块头信息，以及与之相匹配的交易的merkle树。这一对等节点还会发出一条相匹配的交易的tx消息。

## 交易池和UTXO池

每个节点还维护着一个未被确认的交易列表，叫交易池。细分为两种：
 1、刚刚加入的交易，还未被确认（交易池）
 2、由于网络延迟等原因，找不到父交易的子交易（孤立交易池）
 新加入交易池的交易，会先在孤立池中寻找父交易，找到之后，就会退出孤立池，进入交易池，等待确认。

> 交易池和孤立交易池（如有实施）都是存储在本地内存中，并不是存储在永久性存储设备（如硬盘）里。更准确的说，它们是随网络传入的消息动态填充的。节点启动时，两个池都是空闲的；随着网络中新交易不断被接收，两个池逐渐被填充。

UTXO数据库，也称UTXO池,保存的是UTXO数据，这个池不像交易池那样变化那么大，交易池每个节点都不一样，而UTXO池基本相同。UTXO池可以在内存，也可以在硬盘。还需要说明的是，UTXO池只包含确认过的交易。

## 警告消息

> 警告消息并不经常使用，但在大多数节点上都有此功能。警告消息是比特币的“紧急广播系统”，比特币核心开发人员可以借此功能给所有比特币节点发送紧急文本消息。
>  警告通过公钥进行加密签名。对应的私钥是由核心开发团队的一些特定成员所持有。这样的数字签名可以确保虚假警告不会在网络中传播。
>  收到警告消息的节点会验证该消息，检查是否过期，并传播给其所有对等节点，从而保证了整个网络中的快速传播。



作者：乔延宏
链接：https://www.jianshu.com/p/a86e19c7fd9e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 比特币：网络架构

比特币采用去中心化的P2P（点对点）的网络架构，所谓P2P是指网络中的每个节点都是对等的，不存在「特权」节点，这也是比特币「去中心化」的底层实现。

虽然比特币P2P网络中每个节点是对等的，但根据其功能不同，分为如下几种节点类型：



![img](https://ask.qcloudimg.com/http-save/yehe-1000017/rmciqho241.jpeg?imageView2/2/w/1620)

下面我来一一阐述每种节点的作用：

## 网络路由节点

拥有网络路由功能的节点都可以作为网络路由节点，所有的网络路由节点通过TCP协议连成一张巨大的P2P网络。这里需要注意，对于单个节点来说，它并不需要与其它所有节点建立直接连接，否则性能会成为瓶颈，它只需要跟其相邻的几个节点建立直接连接即可，和其它节点是间接连接。

## 全节点

全节点是指包含完整区块链数据库的节点，我们知道比特币从2009年1月诞生以来，平均每10分钟产生1个区块，目前为止已经产生了51万个区块，至少需要占用150G的磁盘空间。比特币刚诞生的时候，区块链数据库很小，大部分都是全节点，但随着区块链数据库越来越大，全节点的比例在不断缩小。

## 简单支付验证（SPV）节点

对于跑在智能手机上的钱包客户端来说，下载整个区块链数据库肯定是不可行的（想象下如果你的iPhone手机为了跑比特币客户端需要占用超过150G的空间，我相信你肯定不会用它）。于是，简单支付验证（SPV）节点孕育而生，SPV节点只需要下载区块头，不用下载区块身（即交易信息），因此它占用的空间大大减少。

## 独立矿工节点

所谓独立矿工节点是跟矿池相对立，是指不依赖其它节点的算力、单独进行挖矿的节点，因此它拥有完整的区块链数据库。在比特币前期，由于全网的算力不大，独立矿工还有生存空间（比如前几年比较流行的个人买矿机挖矿，甚至有些人还在手机上挖矿），但随着比特币价格一路攀升，全网算力越来越大，独立矿工节点的生存空间越来越小，除非是大的数据中心。

## 矿池及其挖矿节点

前面说过，随着比特币全网算力越来越大，独立矿工挖到矿的概率越来越小，因此就产生了矿池。所谓矿池是指很多个挖矿节点集合在一起组成挖矿联盟，如果挖到矿，所获得的收益根据挖矿节点贡献的算力分摊，当然矿池还会收一部分管理费。这个挖矿联盟一般基于Pool或Stratum协议。

综上所述，比特币网络架构如下图所示：



未完待续，关注我的公众号可获取后续文章：



# 比特币网络节点：如何分工？如何发现？

## 0.比特币网络简述

> 1）比特币采用了基于国际互联网（Internet）的P2P（peer-to-peer）网络架构（比特币的P2P网络下文会做详细介绍）；
>
> 2）“比特币网络”是按照比特币P2P协议运行的一系列节点的集合；
>
> 除了比特币P2P协议之外，比特币网络中也包含其他协议（比如Stratum协议就被应用于挖矿节点通信&&比特币轻钱包等）；
>
> 3）网关路由服务器（gateway）提供其他协议，并且基于P2P协议将这些协议接入到比特币网络中，并拓展到运行其他协议的各个节点。

## 1.P2P协议概述

> P2P：对等计算机或对等网络。
>
> P2P是一种分布式网络，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源需要由网络提供服务和内容，能被其它对等节点直接访问而无需经过中间实体。
>
> 在此网络中的参与者既是资源提供者，又是资源获取者，网络中的每个节点都是以【扁平】的拓扑结构相互连通。
>
> P2P的特点：
>
> 1）无中央服务器，打破了C/S模式；2）用户之间互联并分享文件；3）非中心化
>
> P2P网络常见的拓扑结构：
>
> 
>
> 1）中心化拓扑（又叫星行拓扑） 2）半中心化拓扑 3）全分布式拓扑（网状/扁平）
>
> 区块链中的P2P拓扑结构采用的是全分布式拓扑结构
>
> 

## 2.区块链中的P2P协议有什么不同？

> P2P的网络协议应用有很多，																                                                                   										规模最大也最成功的领域就是文件分享领域：比如BitTorrent（比特流：是一种内容分发协议，由布拉姆·科恩自主开发）；比如Napster;
>
> 比特币&以太坊等区块链实现了适合自己网络的定制化的P2P网络协议，与上述P2P协议稍有不同。
>
> 1）比特币的P2P网络是基于TCP协议构建的，主网默认通信端口8333；
>
> 2）以太坊的P2P网络是一个完全加密的网络，提供UDP和TCP两种连接方式（节点发现使用的UDP，节点间信息交互使用的是TCP），主网默认TCP通信端口30303，UDP端口30301；
>
> 区块链中的P2P协议，担负的职责有很多，比如节点发现与路由，比如节点交互等。

## 3.节点的功能有哪些？

> 一：由上我们知道，比特币网络的核心基础协议是P2P，比特币网络中的其他协议都是通过桥接服务器接入P2P网络，并且P2P网络中的节点都是对等的。
>
> 虽然，比特币网络中的节点是对等的，但是根据节点所承载的功能不同，不同节点在整个比特币网络中的分工也不同。
>
> 二：节点总共承载四个功能：
>
> （1）挖矿：即部署了Stratum服务器的节点
>
> （2）钱包：即转账交易功能
>
> （3）路由
>
> （4）区块链数据库：即Local存储区块链全部数据
>
> 如下图所示：

![img](https:////upload-images.jianshu.io/upload_images/10422519-214869b166792ca9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1114/format/webp)

比特币网络节点

> 1）“网络路由”：功能是所有节点都具备的功能，也就是说不具备“网络路由功能的”节点不能称之为“比特币网络节点”；
>
> 2）”完整区块链“：指的是节点本地保存一份完整的并且最新的区块链全部数据。这样的节点，我们称之为“全节点”Full Node；
>
> 反之，有的节点只保存了部分的区块链数据（一般是运行SPV协议，本地保存区块头部SPV认证信息），这样的节点我们称之为“SPV节点”或者“轻量级节点”；
>
> 3）“挖矿”：指的是那些运行在特殊设备上，并且运行POW算法的节点，通过POW算法来互相竞争新区块的生成权；
>
> 4）“钱包”：用户的钱包也可以作为比特币网络的一个节点，比如BitCoin Core桌面钱包，以及SPV移动端轻量级钱包等。

## 4.节点的分类与分工

> 根据节点拥有上述四个功能中的多少来分类，比特币网络节点可以分为如下几种：
>
> 1）bitcoin core 比特币核心客户端
>
> 在比特币网络中，包含钱包，挖矿，完整的区块链数据，网络路由节点。



![img](https:////upload-images.jianshu.io/upload_images/10422519-9382b4a8dc4a8328.png?imageMogr2/auto-orient/strip|imageView2/2/w/416/format/webp)

core

> 2）完整区块链节点
>
> 在比特币网络中，包含完整的区块链数据和网络路由节点；

![img](https:////upload-images.jianshu.io/upload_images/10422519-923cc6cee0021d08.png?imageMogr2/auto-orient/strip|imageView2/2/w/424/format/webp)

full Node

> 3）独立矿工
>
> 本地拥有完整的区块链数据，无需实时与其他节点进行数据验证；拥有网络路由功能（所以可视为网络节点）；运行POW挖矿算法；



![img](https:////upload-images.jianshu.io/upload_images/10422519-0e2430ce0bb1b712.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)

独立矿工

> 4）SPV轻钱包
>
> 不存储区块链所有数据，只保存SPV认证所需的必要信息；包含网络路由节点。



![img](https:////upload-images.jianshu.io/upload_images/10422519-0fb6b5127dbe94dc.png?imageMogr2/auto-orient/strip|imageView2/2/w/476/format/webp)

SPV钱包

> 以上，即是网络节点的大致分类，而我们也知道，“矿工”这个角色对于维护比特币网络的安全，对全网交易的进行发挥着举足轻重的作用，那么，根据矿工接入P2P网络的方式来区分，又分为几种类型的“矿工”呢？

## 5.“矿工”的分类

> 1）独立矿工
>
> 上文已经描述。

> 2）Stratum矿工（运行Stratum服务器）
>
> 运行Stratum挖矿协议的矿工（非节点）属于Stratum主服务器的子服务器；

![img](https:////upload-images.jianshu.io/upload_images/10422519-490ddd053680c2da.png?imageMogr2/auto-orient/strip|imageView2/2/w/304/format/webp)

Stratum协议矿工

> 3）矿池协议矿工（运行Pool服务器）
>
> 运行矿池挖矿协议的矿工服务器，通过Pool协议与Pool矿池主服务器进行交互；
>
> 矿池组，只有PooL矿池主服务器与P2P网路链接，大致的网络拓扑图如下：



![img](https:////upload-images.jianshu.io/upload_images/10422519-6c8aa3d20cfcdc1d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

简易化“矿工”网路拓扑图

## 6.网络节点如何发现？

> 在一个中心化的拓扑结构中，任何加入的网络的新节点只要连接到中心节点即可；
>
> 但是，比特币中的P2P网络节点都属于“对等节点”，那么比特币网络如何在“去中心化”的拓扑结构下，动态维护网络节点的呢？

> 当一个新的网络节点启动之后，该节点需要快速的与任何一个保持活跃状态的对等节点完成通信，加入到比特币网络中参与协同运作；
>
> 由于比特币网络的拓扑结构是不基于物理地址的，所以相邻节点的概念与物理信息无关；在新节点连接时，可以随机选择网络中存在的比特币节点与之相连。

#### 节点之间的通信过程

> 1）对等节点之间是使用TCP协议进行握手通信的，主网默认通信端口8333；
>
> 2）通信交互的信息为，新加入节点A运行的P2P协议版本信息Version，BestHeight等（BestHeight字段标示了一个节点当前的区块链高度)，对等节点B接收到之后，会回复一个VersionAck信息。
>
> 3）对等节点B主动发起链接，发送本节点运行的P2P协议版本信息Version等，新加入节点A接收到之后，要恢复对等节点一个VersionAck信息。
>
> 4）新加入节点A发送一个getAddress()请求，要求对等节点B返回其已知的其他对等节点的IP地址列表。通过这种方式，新加入节点A可以找到需连接到的对等节点集合，并向网络发布它的消息以便其他节点查找。
>
> 5）新加入节点A，发送getBlocks()请求，对等节点B会返回B本地保存的顶端区块哈希值。如果节点A识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，那么它就能推断出：其自身的本地区块链比其他对等节点的区块链更长。
>
> 6）拥有更长区块链的对等节点，会向全网广播出去，其他对等节点如果需要补充区块，则会向该拥有最长区块链的节点发起getdata()请求，获取全部数据；
>
> Q&A：
>
> 1）以上过程为曾经加入过比特币网络中的FullNode节点 再次动态加入的过程，如果是一个新的FullNode节点呢？
>
> 那么它就不包含任何区块链信息，它只知道一个区块——静态植入在客户端软件中的创世区块。新节点需要下载从0号区块（创世区块）开始的数十万区块的全部内容，才能跟网络同步、并重建全区块链。
>
> 2）如果新加入的节点是一个SPV节点（轻量级节点）呢？
>
> SPV节点使用的是一条getheaders消息，而不是getblocks消息来获得区块头。发出响应的对等节点将用一条headers消息发送多达2000个区块头。这一过程和全节点获取所有区块的过程没什么区别。
>
> SPV节点还在与对等节点的连接上设置了布隆过滤器，用以过滤从对等节点发来的未来区块和交易数据流。任何目标交易都是通过一条getdata的请求来读取的。

以上，即时本期关于比特币P2P网络的所有内容，欢迎各位看官diss哦~~~



作者：贝壳儿说
链接：https://www.jianshu.com/p/5e10322fc287
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





# 比特币网络中的区块链

## 概述

区块是交易的集合，区块相互咬合成为区块链。
 为什么要咬合？因为这种咬合关系，构成父子孙的牢不可破的稳定关系，才使得账本不可篡改。
 怎么咬合的？每个区块头里面包含“父区块哈希值”字段，也就是记得自己的父区块信息，这样最终形成一根长链条，父子孙区块的顺序是对每个区块头进行SHA256加密哈希，可生成一个哈希值，再通过这个哈希值，可以识别出区块链中的对应区块。

## 区块结构

区块头是80字节，平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头的1000倍还要大。



![img](https:////upload-images.jianshu.io/upload_images/1785959-3a577269285489b9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1084/format/webp)

区块结构

## 区块头

![img](https:////upload-images.jianshu.io/upload_images/1785959-a10d0b71f30c3675.png?imageMogr2/auto-orient/strip|imageView2/2/w/1162/format/webp)

区块头由三组区块元数据组成。首先是一组引用父区块哈希值的数据，这组元数据用于将该区块与区块链中前一区块相连接。第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关。第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构）。



# 如何识别一个区块：区块标识符和区块高度

用什么唯一标识一个区块，就是区块标识符，又叫区块哈希值。如何唯一标识一个区块，就是通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。网络中每个节点都可以对区块头进行哈希计算得到区块标识符。
 相信大家注意到了，这个概念不存在数据结构中，它是当该区块从网络被接收时由每个节点计算出来的。区块标识符可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。
 还有一个概念也可以识别区块，就是区块高度。第一个区块，其区块高度为0，后续的区块比它高1。在区块链分叉环境中，区块高度和区块标识符不是一一对应的。同样区块高度也不是区块头数据结构中。

## 第一个区块：创世纪区块

不管是什么样的节点，都必须明确创世纪的区块标识符。这样做的目的是所有节点认祖归宗，只有一个祖先。

## 区块是如何认祖归宗的？

每个区块有自己的区块标识符（区块哈希值），然后在区块头中还清楚记得自己的父区块的区块哈希值，这个是节点在添加一个节点时必须做的。

## Merkle 树

默克树是区块头数据结构中的一个字段，他的作用是记录这个区块中所有的交易信息。

> 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。生成一棵完整的Merkle树需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根。在比特币的Merkle树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。
>  当N个数据元素经过加密后插入Merkle树时，你至多计算2*log2(N)次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。



![img](https:////upload-images.jianshu.io/upload_images/1785959-6f128a31b7174cc0.png?imageMogr2/auto-orient/strip|imageView2/2/w/956/format/webp)

在Merkle树中计算节点


 上图是只有4笔交易的默克树。首先对交易进行哈希，比如HA = SHA256(SHA256(txA))，HB = SHA256(SHA256(txB))，然后将这两片叶子组成一个树枝：HAB=SHA256(SHA256(HA + HB))。最后形成树根HABCD=SHA256(SHA256(HAB + HCD))



![img](https:////upload-images.jianshu.io/upload_images/1785959-e33af8543937eba6.png?imageMogr2/auto-orient/strip|imageView2/2/w/957/format/webp)

一颗囊括了许多数据元素的Merkle树以及其中的交易路径

真正的区块可能包括成千上百个交易，如何在一个区块头中完整记录这样的交易信息，数据量将非常惊人。通过这种方法就可以将无论多少交易信息变为最后的默克树根，这些交易都会采用这样的方法归纳起来，产生一个仅仅32字节的数据作为Merkle根。无论区块中有一个交易或者有十万个交易，Merkle根总会把所有交易归纳为32字节。这将大大节省数据空间。
 除此之外的好处，计算工作量的减轻。任何一个节点想要证明一笔交易所处的区块，只需要进行与该笔交易相关的哈希，就可以验证。就像上图中：

> 一个节点能够通过生成一条仅有4个32字节哈希值长度（总128字节）的Merkle路径，来证明区块中存在一笔交易K。该路径有4个哈希值（在上图中由蓝色标注）HL、HIJ、HMNOP和HABCDEFGH。由这4个哈希值产生的认证路径，再通过计算另外四对哈希值HKL、HIJKL、HIJKLMNOP和Merkle树根（在图中由虚线标注），任何节点都能证明HK（在图中由绿色标注）包含在Merkle根中。

实际比特币网络中，要找到上千笔交易中的一笔交易，比特币节点就能够通过高效地产生一条10或者12个哈希值（320-384字节）的路径来实现。Merkle树的高效随着交易规模的增加而变得异常明显。



![img](https:////upload-images.jianshu.io/upload_images/1785959-057ed12db08de625.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

​                                                                       Merkle树的效率

## 简单支付验证（SPV）

默克树根的机制为SPV实现提供了可能。SPV节点只需要区块头信息就可以进行验证一笔交易在默克树跟中的路径，并实现交易的确认。
 具体来讲，SPV钱包要验证一笔交易，先在通信链接上建立起bloom过滤器，找到符合过滤条件的交易地址。其他节点找到符合的地址后，就给SPV节点发个消息：区块哈希值，连接目标交易与Merkle根的Merkle路径。SPV节点找到区块，验证交易。

> 简而言之，SPV节点会收到少于1KB的有关区块头和Merkle路径的数据，其数据量比一个完整的区块（目前大约有1MB）少了一千倍有余。



作者：乔延宏
链接：https://www.jianshu.com/p/61f00d7bb64e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

4.2挖矿原理
首先介绍一下比特币每个区块的数据结构，每个区块由区块头和区块体两部分组成。

区块体中包含了矿工搜集的若干交易信息，图中假设有8个交易被收录在区块中，所有的交易生成一颗默克尔树，默克尔树是一种数据结构，它将叶子节点两两哈希，生成上一层节点，上层节点再哈希，生成上一层，直到最后生成一个树根，称之为默克尔树根，只有树根保留在区块头中，这样可以节省区块头的空间，也便于交易的验证。

区块头中包含父区块的哈希，版本号，当前时间戳，难度值，随机数和上面提到的默克尔树根。



 

 

假设区块链已经链接到了某个块，有ABCD四个节点已经搜集了前十分钟内全网中的一些交易信息，他们选出其中约4k条交易，打包好，生成默克尔树根，将区块头中的信息，即发区块哈希+版本号+时间戳+难度值+随机数+默克尔树根组成一个字符串str，通过两次哈希函数得出一个256的二进制数，即SHA256(SHA256(str)) = 10010011……共256位，比特币要求，生成的结果，前n位必须是0，n就是难度值，如果现在生成的二进制数不符合要求，就必须改变随机数的值，重新计算，只到算出满足条件的结果为止。假设现在n是5，则生成的二进制数必须是00000……(共256位)。一旦挖矿成功，矿工就可以广播这个消息到全网，其他的矿工就会基于该区块继续挖矿。下一个区块头中的父区块哈希值就是上一个区块生成的00000……这个数。

解决这个数学难题要靠运气，理论上，运气最好的矿工可能1次哈希就能算出结果，运气差的可能永远都算不出来。但是总体来看，如果一个矿工的算力越大，单位时间内进行的哈希次数就越多，就越可能在短时间内挖矿成功。

那么n是如何确定的呢？比特币设计者希望，总体上平均每十分钟产生一个区块，总体上来看，挖矿成功的概率为1/2^n。现假设世界上有1W台矿机，每台矿机的算力是14T次/s = 1.4×10^13次/s，单位次/s称之为哈希率，10分钟是600s，所以10分钟可以做8×10^19次哈希运算，从概率角度看，想要挖矿成功需要做2^n次运算，可以列出等式2^n = 8×10^19，可以解出n约为66。所以对于这种方法，我们没有办法使得自己的运气变的更好，只能提高自己的算力，尽快的算出结果。
————————————————
版权声明：本文为CSDN博主「东大大数据组Zzzcg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zcg_741454897/article/details/102796022



# 一个完整的比特币交易流程是怎么样的？

本文解释了比特币交易的内容，目的和结果。下面的解释适用于新手和中级比特币用户。

作为加密货币用户，你需要熟悉交易雏形——为了你对这种不断发展的创新有信心，以及作为理解新兴多签名交易和合约的基础，这两者都将在本系列的后期进行探讨。这不是纯技术文章，解释将集中在你需要了解的标准比特币交易——我们通常做的支出交易——并且我们将掩盖你可以安全忽略的内容。

本文底部的信息图提供了从钱包到区块链的整个比特币交易流程的全面说明。

注意：即使是核心开发人员也承认，用于描述交易及其组件的某些语言可能导致人们误解了实际发生的事情。在下面的解释中避免了这些误解。因此，在尝试尽可能简单的描述的同时，借助一些图表，让我们直接开始。

### 术语和缩写的定义

- Bitcoin：具有大写`B`的比特币指的是协议——代码，节点，网络及其对等交互。
- bitcoin：用小写字母`b`表示货币——我们通过比特币网络发送和接收的加密货币。
- tx：在文本中使用的任何地方——是比特币交易`‘Bitcoin transaction`的缩写。
- txid：是`transaction id`的缩写——这是人和协议引用交易的哈希。
- Script：是比特币协议的脚本系统的名称，用于处理和验证交易——脚本是一个聪明的，基于堆栈的指令引擎，它使得从简单支付到复杂的oracle监督合约的所有交易成为可能。
- UTXO：`Unspent Transaction Output`的缩写，也称为“输出”。
- satoshi：1 BTC = 100,000,000 satoshi

### 什么是比特币交易？为什么？

1.定义

比特币交易是一个经过签名的数据，它被广播到网络上，如果有效，最终会进入区块链的一个区块。

2.目的

比特币交易的目的是将一定数量的比特币的所有权转移到比特币地址。

3.结果

当你发送比特币时，你的钱包客户端会创建一个单一的数据结构，即比特币交易，然后广播到网络。网络上的比特币节点将中继和重新广播交易，如果交易有效，节点将把它包含在他们正在挖掘的块中。通常，在10-20分钟内，交易将与区块链中的一个区块中的其他交易一起被包括在内。此时接收者能够看到他们钱包中的交易金额。

4.例子

以下是今年早些时候区块链中包含的示例交易：

![img](https:////upload-images.jianshu.io/upload_images/11831773-410664a3c4a0e27b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1185/format/webp)

image

此标准交易的主要组成部分采用颜色编码：

- 交易ID（以黄色突出显示）
- 描述符和元数据（蓝色花括号在右边详细说明）
- 输入（粉色区域）
- 输出（绿色区域）

### 比特币交易输入和输出

首先，关于交易的四个公理：

- 我们发送的任何比特币金额总是发送到一个地址。
- 我们收到的任何比特币金额都被锁定在接收地址——这通常与我们的钱包相关联。
- 每当我们花费比特币时，我们花费的金额将始终来自之前收到的并且目前存在于我们钱包中的资金。
- 地址接收比特币，但他们不发送比特币——比特币是从钱包发送的。

进入我们钱包的金额并不像实体钱包中的硬币那样混乱。收到的金额不会混合，但保持独立且与钱包收到的确切金额不同。这是一个例子：

示例：

你创建一个全新的钱包，并及时收到三个0.01,0.2和3BTC的金额，如下所示：你将3BTC发送到与钱包相关联的地址，并由Alice向另一个地址付款。

![img](https:////upload-images.jianshu.io/upload_images/11831773-30014950535a3e22.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

钱包报告的余额为3.21BTC，但如果你真的看钱包里面，你会看到——不是321,000,000 satoshi（321 mil satoshi），但是三个不同的数量仍然由他们的原始交易组合在一起：0.01,0.2和3BTC。

![img](https:////upload-images.jianshu.io/upload_images/11831773-f5304ef088bb1585.png?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp)

image

收到的比特币金额不会混合，但保持分开，作为发送到钱包的确切金额。上例中的三个金额称为其原始交易的输出。

比特币钱包始终保持输出分离和独特。

输出`output`是（通过标准交易）发送到比特币地址的金额，以及解锁输出金额的一组规则。在比特币用语中，输出称为“未使用的交易输出”或`UTXO`。

可以使用与接收地址相关联的私钥解锁标准交易输出。地址及其相关的公钥/私钥对将在本系列的后面部分介绍。目前，我们只关注总数。

示例：

让我们考虑一个例子，在你向Bob发送0.15BTC的情况下跟踪钱。

正如我们所看到的，你的钱包没有选择15mil miloshi（0.15 BTC）来自一个无差别的321 mil satoshi组成钱包余额。相反，钱包从钱包中包含的三个现有输出`outputs`中选择一个支出候选者。因此，它选择（由于各种原因，现在不重要）0.2BTC输出。钱包将解锁0.2 BTC输出并使用全部0.2BTC作为新的0.15 BTC交易的输入`input`。0.2BTC输出在此过程中花费`spent`。

![img](https:////upload-images.jianshu.io/upload_images/11831773-c4b4473c4584adec.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

你的钱包创建的花费交易将向Bob的地址发送0.15BTC——它将作为输出存放在他的钱包中——等待最终花费。

0.05BTC差额（0.2 BTC输入减去0.15 BTC输出）称为改变`change`，交易将通过新创建的地址将其发送回你的钱包。0.05 BTC改变的金额将作为新输出存放在你的钱包中——等待最终花费。所以，现在你钱包里会显示以下内容：

![img](https:////upload-images.jianshu.io/upload_images/11831773-bea952d3b16b021e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

image

“等待花费”的三个输出中的每一个被锁定到其接收地址，直到选择它们中的一个或多个作为新花费交易的输入为止。

在后台，当选择`UTXO`作为新交易的输入时，不同的钱包客户端应用不同的逻辑规则。一个理智的钱包策略是尽可能先使用旧的`UTXO`，但实现方式不同。我们现在并不关注选择`UTXO`的方式，因为我们的目标一直是强调我们的钱包收到的金额是分开的和不同的。

### 比特币交易如何完成的总结

各种收到的金额不会像在实体钱包中那样混合。相反，在我们花费比特币时，收到的金额（UTXO）被单独使用（或组合使用）。在创建支出交易时，我们的钱包选择UTXO（具有足够的价值以满足我们想要发送的金额）并且通常创建两个新输出：一个用于接收器，一个用于我们收到的更改到钱包。更改成为我们钱包中的全新UTXO，我们发送的金额成为锁定到收件人地址的UTXO——可能与钱包相关联，也可能不与钱包相关联，例如冷存储。用作支出交易的输入的原始UTXO将“花费”并永久销毁。

这是钱包软件如何处理输出（UTXO）的介绍。一旦选择了UTXO用于支出，它就需要与接收它的地址相关联的私钥。此私钥兑换UTXO并允许它成为新支出交易中的输入。以前的交易输出被重新用作新交易的输入的机制是比特币协议功能的核心——完全符合Satoshi的设计。

建议你浏览我们汇智网的各种编程语言的区块链教程和区块链技术博客，深入了解区块链，比特币，加密货币，以太坊，和智能合约。

> - [java比特币开发教程](http://xc.hubwiz.com/course/5bb35c90c02e6b6a59171df0?affid=1021jianshu)，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Java代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Java工程师不可多得的比特币开发学习课程。
> - [php比特币开发教程](http://xc.hubwiz.com/course/5b9e779ac02e6b6a59171def?affid=1021jianshu)，本课程面向初学者，内容即涵盖比特币的核心概念，例如区块链存储、去中心化共识机制、密钥与脚本、交易与UTXO等，同时也详细讲解如何在Php代码中集成比特币支持功能，例如创建地址、管理钱包、构造裸交易等，是Php工程师不可多得的比特币开发学习课程。
> - [php以太坊](http://xc.hubwiz.com/course/5b36629bc02e6b6a59171de3?affid=1021jianshu)，主要是介绍使用php进行智能合约开发交互，进行账号创建、交易、转账、代币开发以及过滤器和交易等内容。
> - [java以太坊开发教程](http://xc.hubwiz.com/course/5b2b6e82c02e6b6a59171de2?affid=1021jianshu)，主要是针对java和android程序员进行区块链以太坊开发的web3j详解。
> - [以太坊入门教程](http://xc.hubwiz.com/course/5a952991adb3847553d205d1?affid=1021jianshu)，主要介绍智能合约与dapp应用开发，适合入门。
> - [以太坊开发进阶教程](http://xc.hubwiz.com/course/5abbb7acc02e6b6a59171dd6?affid=1021jianshu)，主要是介绍使用node.js、mongodb、区块链、ipfs实现去中心化电商DApp实战，适合进阶。
> - [python以太坊](http://xc.hubwiz.com/course/5b40462cc02e6b6a59171de4?affid=1021jianshu)，主要是针对python工程师使用web3.py进行区块链以太坊开发的详解。
> - [C#以太坊](http://xc.hubwiz.com/course/5b6048c3c02e6b6a59171dee?affid=1021jianshu)，主要讲解如何使用C#开发基于.Net的以太坊应用，包括账户管理、状态与交易、智能合约开发与交互、过滤器和交易等。
> - [EOS入门教程](http://xc.hubwiz.com/course/5b52c0a2c02e6b6a59171ded?affid=1021jianshu)，本课程帮助你快速入门EOS区块链去中心化应用的开发，内容涵盖EOS工具链、账户与钱包、发行代币、智能合约开发与部署、使用代码与智能合约交互等核心知识点，最后综合运用各知识点完成一个便签DApp的开发。

汇智网原创翻译，转载请标明出处。这里是[原文](http://blog.hubwiz.com/2018/10/21/bitcoin-Transaction-Works/)



作者：编程狂魔
链接：https://www.jianshu.com/p/0f1b9c43717a
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# P2P网络架构

[![img](https://upload.jianshu.io/users/upload_avatars/11530250/48eafeb8-1f6b-4c37-b828-f79c95b48b03?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp)](https://www.jianshu.com/u/750352d3153a)

[建怀](https://www.jianshu.com/u/750352d3153a)关注

0.3362018.06.28 15:32:39字数 7,443阅读 4,321

“比特币网络”是按照比特币P2P协议运行的一系列节点的集合。除了比特币P2P协议之外，比特币网络中也包含其他协议。例如Stratum协议就被应用于挖矿、以及轻量级或移动端比特币钱包之中。网关（gateway）路由服务器提供这些协 议，使用比特币P2P协议接入比特币网络，并把网络拓展到运行其他协议的各个节点。例如，Stratum服务器通过 Stratum协议将所有的Stratum挖矿节点连接至比特币主网络、并将Stratum协议桥接（bridge）至比特币P2P协议之 上。我们使用“扩展比特币网络（extended bitcoin network）”指代所有包含比特币P2P协议、矿池挖矿协议、Stratum 协议以及其他连接比特币系统组件相关协议的整体网络结构。

### 节点类型及角色

尽管比特币P2P网络中的各个节点相互对等，但是根据所提供的功能不同，各节点可能具有不同的角色。每个比特币节点都是路由、区块链数据库、挖矿、钱包服务的功能集合。一个全节点（full node）包括如图所示的四个功能：

![img](https://upload-images.jianshu.io/upload_images/11530250-004c109c701f14f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/906/format/webp)

image

比特币网络节点，具有所有四个功能：钱包，矿工，完整的区块链数据库和网络路由

##### 全节点和轻量级节点

一些节点保有一份完整的、最新的区块链拷贝，这样的节点被称为“全节点”。全节点能够独立自主地校验所有交易，而不需借由任何外部参照。另外还有一些节点只保留了区块链的一部分，它们通过一种名为“简易支付验证（SPV）”的方 式来完成交易验证。这样的节点被称为“SPV节点”，又叫“轻量级节点”。

###### 矿池的由来

挖矿节点通过运行在特殊硬件设备上的工作量证明（proof-of-work）算法，以相互竞争的方式创建新的区块。一些挖矿 节点同时也是全节点，保有区块链的完整拷贝；还有一些参与矿池挖矿的节点是轻量级节点，它们必须依赖矿池服务器维护的全节点进行工作。

### 扩展比特币网络

比特币P2P网络中的一小部分节点也是挖矿节点，它们竞争挖矿、验证交易、并创建新的区块。许多连接到比特币网络的大型公司运行 着基于Bitcoin核心客户端的全节点客户端，它们具有区块链的完整拷贝及网络节点，但不具备挖矿及钱包功能。这些节点是网络中的边缘路由器（edge routers），通过它们可以搭建其他服务，例如交易所、钱包、区块浏览器、商家支付处理（merchant payment processing）等。

扩展比特币网络既包括了运行比特币P2P协议的网络，又包含运行特殊协议的网络节点。比特币P2P主网络上连接着许多矿池服务器以及协议网关，它们把运行其他协议的节点连接起来。这些节点通常都是矿池挖矿节点以及轻量级钱包客户端，它们通常不具备区块链的完整备份。

### 比特币传播网络

比特币传播网络是一种尝试最小化矿工之间传输块的延迟的网络。

原始的比特币传播网络在2016年被替换为Fast Internet Bitcoin Relay Engine or [FIBRE](http://bitcoinfibre.org/)，也由核心开发商Matt Corallo创建。 FIBER是一种基于UDP的中继网络，可以中继节点网络内的块。 FIBER实现了compact block，以进一步减少传输的数据量和网络延迟。

传播网络不是比特币的P2P网络的替代品。相反，它们是覆盖网络，在具有特殊需求的节点之间提供额外的连接像高速公路不是农村道路的替代品，而是交通繁忙的两点之间的快捷方式，您仍然需要小路连接高速公路。

### 网络发现

当新的网络节点启动后，为了能够参与协同运作，它必须发现网络中的其他比特币节点。新的网络节点必须发现至少一个网络中存在的节点并建立连接。由于比特币网络的拓扑结构并不基于节点间的地理位置，因此各个节点之间的地理信息完全无关。在新节点连接时，可以随机选择网络中存在的比特币节点与之相连。

节点通常采用TCP协议、使用8333端口（该端口号通常是比特币所使用的，除8333端口外也可以指定使用其他端口） 与已知的对等节点建立连接。在建立连接时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通信过程。

![img](https://upload-images.jianshu.io/upload_images/11530250-ceda755b74883bd6.png?imageMogr2/auto-orient/strip|imageView2/2/w/872/format/webp)

image

版本消息始终是任何对等体发送给另一个对等体的第一条消息。 接收版本消息的本地对等体将检查远程对等体报告的nVersion，并确定远端对等体是否兼容。 如果远程对等体兼容，则本地对等体将确认版本消息，并通过发送一个verack建立连接。

新节点如何找到对等体？ 第一种方法是使用多个“DNS种子”来查询DNS，这些DNS服务器提供比特币节点的IP地址列表。 其中一些DNS种子提供了稳定的比特币侦听节点的静态IP地址列表。 一些DNS种子是BIND（Berkeley Internet Name Daemon）的自定义实现，它从搜索器或长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集。

不知道网络的引导节点必须被给予至少一个比特币节点的IP地址，之后可以通过进一步介绍来建立连接。 命令行参数-seednode可用于连接到一个节点，仅用于将其用作种子。 在使用初始种子节点形成介绍后，客户端将断开连接并使用新发现的对等体。

当建立一个或多个连接后，新节点将一条包含自身IP地址的addr消息发送给其相邻节点。相邻节点再将此条addr消息依 次转发给它们各自的相邻节点，从而保证新节点信息被多个节点所接收、保证连接更稳定。另外，新接入的节点可以向 它的相邻节点发送getaddr消息，要求它们返回其已知对等节点的IP地址列表。通过这种方式，节点可以找到需连接到 的对等节点，并向网络发布它的消息以便其他节点查找。下图描述了这种地址发现协议。

![img](https://upload-images.jianshu.io/upload_images/11530250-c11dac9a19fcdbc6.png?imageMogr2/auto-orient/strip|imageView2/2/w/829/format/webp)

image

节点必须连接到若干不同的对等节点才能在比特币网络中建立通向比特币网络的种类各异的路径（path）。由于节点可以随时加入和离开，通讯路径是不可靠的。因此，节点必须持续进行两项工作：在失去已有连接时发现新节点，并在其他节点启动时为其提供帮助。节点启动时只需要一个连接，因为第一个节点可以将它引荐给它的对等节点，而这些节点又会进一步提供引荐。一个节点，如果连接到大量的其他对等节点，这既没必要，也是对网络资源的浪费。在启动完成 后，节点会记住它最近成功连接的对等节点；因此，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。如果先前的网络的对等节点对连接请求无应答，该节点可以使用种子节点进行重启动。

在运行比特币核心客户端的节点上，您可以使用 getpeerinfo 命令列出对等节点连接信息：

$ bitcoin-cli getpeerinfo



```bash
{
    "addr" : "85.213.199.39:8333",
    "services" : "00000001",
    "lastsend" : 1405634126,
    "lastrecv" : 1405634127,
    "bytessent" : 23487651,
    "bytesrecv" : 138679099,
    "conntime" : 1405021768,
    "pingtime" : 0.00000000,
    "version" : 70002,
    "subver" : "/Satoshi:0.9.2.1/",
    "inbound" : false,
    "startingheight" : 310131,
    "banscore" : 0,
    "syncnode" : true
},
{
    "addr" : "58.23.244.20:8333",
    "services" : "00000001",
    "lastsend" : 1405634127,
    "lastrecv" : 1405634124,
    "bytessent" : 4460918,
    "bytesrecv" : 8903575,
    "conntime" : 1405559628,
    "pingtime" : 0.00000000,
    "version" : 70001,
    "subver" : "/Satoshi:0.8.6/",
    "inbound" : false,
    "startingheight" : 311074,
    "banscore" : 0,
    "syncnode" : false
}
```

用户可以通过提供 -connect=<IP地址> 选项来指定一个或多个IP地址，从而达到覆盖自动节点管理功能并指定IP地址列表的目的。如果采用此选项，节点只连接到这些选定的节点IP地址，而不会自动发现并维护对等节点之间的连接。

如果已建立的连接没有数据通信，所在的节点会定期发送信息以维持连接。如果节点持续某个连接长达90分钟没有任何通信，它会被认为已经从网络中断开，网络将开始查找一个新的对等节点。因此，比特币网络会随时根据变化的节点及网络问题进行动态调整，不需经过中心化的控制即可进行规模增减的有机调整。

### 全节点

完整区块链节点保有完整的、最新的包含全部交易信息的比特币区块链拷贝，这样的节点可以独立地进行建立并校验区块链，从第一区块（创世区块）一直建立到网络中最新的区块。完整区块链节点可以独立自主地校验任何交易信息，而不需要借助任何其他节点或其他信息来源。完整区块节点通过比特币网络获取包含交易信息的新区块更新，在验证无误后将此更新合并至本地的区块链拷贝之中。

### 交换“库存清单”

一个全节点连接到对等节点之后，第一件要做的事情就是构建完整的区块链。如果该节点是一个全新节点，那么它就不包含任何区块链信息，它只知道一个区块——静态植入在客户端软件中的创世区块。新节点需要下载从0号区块（创世区块）开始的数十万区块的全部内容，才能跟网络同步、并重建全区块链。

同步区块链的过程从发送version消息开始，这是因为该消息中含有的BestHeight字段标示了一个节点当前的区块链高度（区块数量）。节点可以从它的对等节点中得到版本消息，了解双方各自有多少区块，从而可以与其自身区块链所拥 有的区块数量进行比较。对等节点们会交换一个getblocks消息，其中包含他们本地区块链的顶端区块哈希值（指纹）。如果某个对等节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，那么它就能推断出：其自身的本地区块链比其他对等节点的区块链更长。

拥有更长区块链的对等节点比其他节点有更多的区块，可以识别出哪些区块们是其他节点需要“补充”的。它会识别出第 一批可供分享的500个区块，通过使用inv（inventory）消息把这些区块的哈希值传播出去。缺少这些区块的节点便可以 通过各自发送的getdata消息来请求得到全区块信息，用包含在inv消息中的哈希值来确认是否为正确的被请求的区块， 从而读取这些缺失的区块。

每当一个节点离线，不管离线时间有多长，这个与对等节点比较本地区块链并恢复缺失区块的过程就会被触发。如果一 个节点只离线几分钟，可能只会缺失几个区块；当它离线长达一个月，可能会缺失上千个区块。但无论哪种情况，它都 会从发送 getblocks 消息开始，收到一个inv响应，接着开始下载缺失的区块。库存清单和区块广播协议如下图所示。

![img](https://upload-images.jianshu.io/upload_images/11530250-987c40b68d0597b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/872/format/webp)

image

### SPV节点

SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000。SPV节点不能构建所有可用于消费的UTXO的全貌，这是由于它们并不知道网络上所有交易的完整信息。SPV节点验证交易时所使用的方法略有不同，这个方法需依赖对等节点“按需”提供区块链相关部分的局部视图。

简易支付验证是通过参考交易在区块链中的深度，而不是高度，来验证它们。一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易组成。而一个SPV节点会验证所有区块的链（但不是所有的交易），并且把区块链和有关交易链接起来。

举一个非常简单能快速理解SPV验证交易的例子：比如第300000号区块中的某个交易需要验证，SPV不能验证UTXO是否还未被支付。SPV节点会在该交易信息和它所在的区块之间用merkle路径建立一条链接。
然后SPV节点就等着有6个确认就好了，从300001到300006的6个区块都在这个交易上面时，也就从侧面验证了这个交易是被确认了，这是通过交易的深度来验证交易的有效性。这是根据比特币的代理网关协议，证明该交易不是双重支付。

###### 那SPV如何验证某个交易不存在呢？

一个交易的存在是可能对SPV节点隐藏的。SPV能证实某个交易的存在性，但它不能验证某个交易不存在，因为SPV节点没有一份关于所有交易的记录。
也就是说SPV节点连接的对等点能欺骗这个SPV节点，反正你并没有交易的记录，不能独自进行验证。
这样只要发动对SPV节点的拒绝服务攻击或者双重支付验证攻击，SPV节点就完蛋了。为了防御这些攻击，SPV节点需要随机连接到多个节点，增加与一个可靠节点相连接的概率。
这种随机连接的需求意味着SPV节点也容易受到网络分区攻击或Sybil攻击。

在绝大多数的实际情况中，具有良好连接的SPV节点是足够安全的，它在资源需求、实用性和安全性之间维持恰当的平衡。当然，如果要保证万无一失的安全性，最可靠的方法还是运行完整区块链的节点。

SPV节点使用的是一条getheaders消息，而不是getblocks消息来获得区块头。发出响应的对等节点将用一条headers 消息发送多达2000个区块头。这一过程和全节点获取所有区块的过程没什么区别。SPV节点还在与对等节点的连接上设置了过滤器，用以过滤从对等节点发来的未来区块和交易数据流。任何目标交易都是通过一条getdata的请求来读取的。对等节点生成一条包含交易信息的tx消息作为响应。区块头的同步过程如下图所示。

![img](https://upload-images.jianshu.io/upload_images/11530250-78362e218e945426.png?imageMogr2/auto-orient/strip|imageView2/2/w/873/format/webp)

image

###### SPV询问的隐私风险

由于SPV节点需要读取特定交易从而选择性地验证交易，这样就又产生了隐私风险。与全区块链节点收集每一个区块内的全部交易所不同的是，SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息。例如，监控网络的第三方可以跟踪某个SPV节点上的钱包所请求的全部交易信息，并且利用这些交易信息把比特币地址和钱包的用户关联起来，从而损害了用户的隐私。

在引入SPV节点/轻量级节点后不久，比特币开发人员就添加了一个新功能：Bloom过滤器，用以解决SPV节点的隐私风 险问题。Bloom过滤器通过一个采用概率而不是固定模式的过滤机制，允许SPV节点只接收交易信息的子集，同时不会精确泄露哪些是它们感兴趣的地址。

### Bloom过滤器

Bloom过滤器是一个允许用户描述特定的关键词组合而不必精确表述的基于概率的过滤方法。它能让用户在有效搜索关键词的同时保护他们的隐私。在SPV节点里，这一方法被用来向对等节点发送交易信息查询请求，同时交易地址不会被 暴露。

Bloom过滤器可以让SPV节点指定交易的搜索模式，该搜索模式可以基于准确性或私密性的考虑被调节。一个非常具体 的Bloom过滤器会生成更准确的结果，但也会显示该用户钱包里的使用的地址；反之，如果过滤器只包含简单的关键 词，更多相应的交易会被搜索出来，在包含若干无关交易的同时有着更高的私密性。

### SPV节点如何使用Bloom过滤器

8.10 SPV节点如何使用Bloom过滤器
Bloom过滤器用于过滤SPV节点从其对等体接收的交易（和包含它们的块），仅选择SPV节点感兴趣的交易，而不会泄露其感兴趣的地址或密钥。

SPV节点将初始化“过滤器”为“空”;在该状态下，bloom过滤器将不匹配任何模式。然后，SPV节点将列出所有感兴趣的地址，密钥和散列，它将通过从其钱包控制的任何UTXO中提取公钥哈希和脚本哈希和交易ID来实现。 SPV节点然后将其中的每一个添加到Bloom过滤器，以便如果这些模式存在于交易中，则Bloom过滤器将“匹配”，而不会自动显示模式。

然后，SPV节点将向对等体发送一个过滤器加载消息，其中包含在连接上使用的bloom过滤器。在对等体上，针对每个传入交易检查Bloom过滤器。完整节点根据bloom过滤器检查交易的几个部分，寻找匹配，包括：

- 交易ID
- 每个交易输出的锁定脚本的数据组件（脚本中的每个键和哈希）
- 每个交易输入
- 每个输入签名数据组件（或见证脚本）

通过检查所有这些组件，可以使用Bloom过滤器来匹配公钥哈希，脚本，OP_RETURN值，签名中的公钥或智能合同或复杂脚本的任何未来组件。

在建立过滤器之后，对等体然后将针对bloom过滤器测试每个交易的输出。只有与过滤器匹配的交易才会发送到节点。

响应于来自节点的getdata消息，对等体将发送一个merkleblock消息，该消息仅包含与过滤器匹配的块和每个匹配交易的merkle路径的块头。然后，对等体还将发送包含由过滤器匹配的交易的tx消息。

由于完整节点向SPV节点发送交易，SPV节点丢弃任何误报，并使用正确匹配的交易来更新其UTXO集和钱包余额。随着它更新自己的UTXO集视图，它还会修改bloom过滤器，以匹配任何引用其刚刚发现的UTXO的交易。然后，完整节点使用新的bloom过滤器来匹配新交易，并重复整个过程。

设置bloom过滤器的节点可以通过发送filteradd消息将模式交互式添加到过滤器。要清除bloom过滤器，节点可以发送一个过滤清除消息。因为不可能从Bloom过滤器中删除模式，所以如果不再需要模式，则节点必须清除并重新发送新的布隆过滤器。

[BIP-37 (Peer Services)](http://bit.ly/1x6qCiO)中定义了SPV节点的网络协议和布隆过滤机制。

### SPV节点和隐私

实现SPV的节点的隐私比整个节点更弱。完整节点接收所有交易，因此不会显示关于它的钱包中是否使用某个地址的信息。 SPV节点接收与其钱包中的地址相关的经过过滤的列表。结果，它减少了所有者的隐私。

bloom过滤器是减少隐私损失的一种方式。没有它们，SPV节点将不得不明确地列出它感兴趣的地址，造成严重的隐私违规。然而，即使使用过滤器，对手监控SPV客户端的流量或直接连接到它的P2P网络中的节点可以随时随地收集足够的信息来了解SPV客户端的钱包中的地址。

### 加密和认证连接

作为增加比特币P2P网络隐私和安全性的一种方法，有两种解决方案可以通过BIP-150/151提供通信加密：Tor传输和P2P认证和加密。

#### Tor网络传输

Tor代表洋葱路由网络，是一个软件项目和网络，通过提供匿名，不可追踪和隐私的随机网络路径提供数据的加密和封装。

Bitcoin Core提供了多种配置选项，允许您运行通过Tor网络传输的流量的比特币节点。此外，Bitcoin Core还可以提供Tor隐藏服务，允许其他Tor节点通过Tor直接连接到您的节点。

从Bitcoin Core版本0.12开始，如果能够连接到本地Tor服务，节点将自动提供隐藏的Tor服务。如果您安装Tor并且Bitcoin Core进程作为具有足够权限的用户访问Tor认证cookie的用户运行，则应自动运行。使用debug标志打开Bitcoin Core对于Tor服务的调试，如下所示：



```ruby
$ bitcoind --daemon --debug=tor
```

你应该在日志中看到“tor：ADD_ONION success”，表示Bitcoin Core已经向Tor网络添加了隐藏的服务。

您可以在Bitcoin Core文档（docs / tor.md）和各种在线教程中找到有关运行Bitcoin Core作为Tor隐藏服务的更多说明。

#### 对等认证和加密

BIP-150和BIP-151两种比特币改进方案在比特币P2P网络中增加了对P2P认证和加密的支持。这两个BIP定义了可由兼容的比特币节点提供的可选服务。 BIP-151启用了支持BIP-151的两个节点之间的所有通信的协商加密。 BIP-150提供可选的对等认证，允许节点使用ECDSA和私钥对对方的身份进行身份验证。 BIP-150要求在认证之前，两个节点按照BIP-151建立了加密通信。

截至2017年1月，BIP-150和BIP-151未在Bitcoin Core中实施。但是，这两个提案已由至少一个名为bcoin的替代比特币客户端实施。

BIP-150和BIP-151允许用户运行连接到受信任的完整节点的SPV客户端，使用加密和身份验证来保护SPV客户端的隐私。

此外，可以使用身份验证来创建可信比特币节点的网络，并防止中间人攻击。最后，P2P加密（如果广泛部署）将加强比特币对流量分析和隐私侵权监控的阻力，特别是在互联网使用受到严格控制和监控的极权主义国家。

### 交易池

比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池或交易池。节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所包含的交易。例如，保存用户钱包的节点会利用这个交易池来记录那些网络已经接收但还未被确认的、属于该用户钱包的预支付信息。

随着交易被接收和验证，它们被添加到交易池并通知到相邻节点处，从而传播到网络中。

有些节点的实现还维护一个单独的孤立交易池。如果一个交易的输入与某未知的交易有关，如与缺失的父交易相关，该 孤立交易就会被暂时储存在孤立交易池中直到父交易的信息到达。

当一个交易被添加到交易池中，会同时检查孤立交易池，看是否有某个孤立交易引用了此交易的输出（子交易）。任何 匹配的孤立交易会被进行验证。如果验证有效，它们会从孤立交易池中删除，并添加到交易池中，使以其父交易开始的链变得完整。对新加入交易池的交易来说，它不再是孤立交易。前述过程重复递归寻找进一步的后代，直至所有的后代都被找到。通过这一过程，一个父交易的到达把整条链中的孤立交易和它们的父级交易重新结合在一起，从而触发了整 条独立交易链进行级联重构。

交易池和孤立交易池（如有实施）都是存储在本地内存中，并不是存储在永久性存储设备（如硬盘）里。更准确的说， 它们是随网络传入的消息动态填充的。节点启动时，两个池都是空闲的；随着网络中新交易不断被接收，两个池逐渐被 填充。

有些比特币客户端的实现还维护一个UTXO数据库，也称UTXO池，是区块链中所有未支付交易输出的集合。“UTXO 池”的名字听上去与交易池相似，但它代表了不同的数据集。UTXO池不同于交易池和孤立交易池的地方在于，它在初始 化时不为空，而是包含了数以百万计的未支付交易输出条目，有些条目的历史甚至可以追溯至2009年。UTXO池可能会被安置在本地内存，或者作为一个包含索引的数据库表安置在永久性存储设备中。

交易池和孤立交易池代表的是单个节点的本地视角。取决于节点的启动时间或重启时间，不同节点的两池内容可能有很 大差别。相反地，UTXO池代表的是网络的突显共识，因此，不同节点间UTXO池的内容差别不大。此外，交易池和孤立交易池只包含未确认交易，而UTXO池之只包含已确认交易。



4人点赞



[日记本](https://www.jianshu.com/nb/24140303)