# 图灵机

谈到比特币，很多人都会看到一条“图灵不完备”；谈到以太坊智能合约，又会看到一条“图灵完备”。这图灵完备不完备是什么鬼？听起来云山雾罩的！

其实，这是一个数学和计算机学科的一个概念；对于我这样一个数学和计算机的渣渣来讲，要想讲清楚这个概念实在是难度巨大！不过，我这样的数学渣渣理解出来的东西一般比较好懂，讲出来也会比较简单。

在整个计算机的体系里，是一个概念引出另一个概念，概念套着概念；原因也很简单，因为问题的解决从来都不是一蹴而就的，是渐进的、逐步的、不断优化的。所以了解一个概念时，不可避免地牵引出其他的概念，那么讲清楚这些概念的前世今生，或许让我们对这些概念会有更清晰的认知。

#### 一、计算机发展简史

**我们先来画一个计算机发展的简图：**

![img](https:////upload-images.jianshu.io/upload_images/5320762-d6eb1c2ca3c2be5c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

计算机发展

按照时间的发展顺序：

**1、1900年，**德国的数学家希尔伯特提出了**23个重要的数学问题**。其中第10条是：“数学是可判定的吗？”意思是：能否通过简单机械计算，判定数学命题是对是错？（备注：虽然当时还没有计算机，但我们现在看，“简单机械计算”这不就是让计算机干的活吗？）

**2、1936年，**英国科学家艾伦[·](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5)图灵对这个问题非常感兴趣，进行了深入的研究。他把人类自己的计算过程（把纸上写上相应公式、观察第一步、脑海中思考计算方法、用笔进行计算更改符号及状况、再观察下一步、重复直至题目算完），进行抽象出一种模型：**图灵机**。图灵机就是模仿人的计算过程，有无限多的纸带当计算的纸，读数据就是人眼观察，写数据就是更改结果，控制器就是我们的大脑。如下图：

![img](https:////upload-images.jianshu.io/upload_images/5320762-2775e1708e28eafd.png?imageMogr2/auto-orient/strip|imageView2/2/w/734/format/webp)





**3、1946年**，冯·诺依曼根据图灵研究的基础，确定了现代存储式电子数字计算机的基本结构与工作原理，给出了由控制器、运算器、存储器、输入和输出设备五大部件组成的被称为**冯·诺依曼型计算机**。算是计算机的初始模型。所以冯·诺依曼被尊称为“计算机之父”。不过他很谦虚地称自己是电子计算机的是助产士，并指出电子计算机的真正基本概念来自于图灵。



![img](https:////upload-images.jianshu.io/upload_images/5320762-c4b46ab7abd36ec1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1138/format/webp)

**4、当今的人工智能**的发展，也是有艾伦·图灵的功劳。图灵曾写过一篇《计算机器和智能》的论文，提问“机器会思考吗？”。用于判断机器是否具备智能的试验方法，这种方法被称为“图灵测试。”后来美国某国家实验室根据图灵的理论，在[ENIAC](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FENIAC)上设计出世界上第一个电脑程序的国际象棋－洛斯阿拉莫斯国际象棋。艾伦·图灵被称为“人工智能之父”。

**小结：由以上的计算机演进的过程中可以看到，为了解决数学的计算问题，图灵通过人的计算过程抽象出“图灵机”，而之后的冯诺依曼根据图灵机的理论，确定的计算机的基础模型：输入、输出、存储、控制器和运算器（控制器和运算器目前合并为CPU了）。**

#### 二、图灵相关的概念

从我们的上面简单的描述中，其实就可以看出图灵对世界的计算机发展有着巨大的贡献，图灵机是之后许多理论的基础。无怪乎计算机之父，冯·诺依曼谦虚地称自己是电子计算机的是助产士，并指出电子计算机的真正基本概念来自于图灵。 由图灵相关名词有：图灵机、图灵完备、可计算理论、图灵测试、图灵原理、图灵奖等等，我们分别予以介绍。

![img](https:////upload-images.jianshu.io/upload_images/5320762-a187a697f19b8ce4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1094/format/webp)

**1、图灵机**

图灵机是图灵把人的计算过程进行抽象成模型，一切可以计算的问题都可以通过这个模型来计算和解决。所以说它是计算机概念的雏形。

举个案例：

冯诺依曼提出的模型，输入、输出、存储、控制和运算，就是计算机搭建的模型，不管现在电脑多么复杂，都还是使用这套模型作为基础架构。

**2、可计算性**

有些问题适合用计算机来解决，有些问题不适合用计算机来解决；一般来讲数值计算、或者可以转换为数值计算的问题都是可以用计算机解决的。

可计算性是分等级的，不同的可计算等级代表可以被计算机解决的程度。可以被计算机解决的问题是指“可以在有限步骤内被解决的问题”，而不能地老天荒、无限之行（这也是没有办法轮判断是否能执行。）

**3、图灵完备**

如果指令集、编程语言、虚拟机等可以模拟图灵机，那就是图灵完备的。

好像没有说清楚，再把图灵机补充进去就清晰了:

**图灵完备：如果指令集、编程语言、虚拟机等可以模拟图灵机来计算一切可以计算的问题。**

那么，图灵不完备是指：

**图灵不完备：如果指令集、编程语言、虚拟机等不能实现图灵机那样计算一切可以计算的问题。**



现在的常见的编程语言、虚拟机都是图灵完备的，因为他们模拟出来的就是计算机本身，要实现计算机的一切功能，所以需要图灵完备。

那么有没有需要图灵不完备的情况呢？有的。

有些时候，为了简化问题、避免危险操作、限制权限等等原因，会采用图灵不完备的工具。例如比特币网络的脚本语言，就是图灵不完备的，诸如没有循环语句和复杂的条件控制语句，所以比特币网络就很具备健壮性。

而以太坊网络是提供的运行智能合约的虚拟机，为了让用户智能合约具有更强大的功能，所以是图灵完备的，这个虚拟机模拟出来的机器，和真实的计算机功能是相同的。

举两个未必恰当案例，协助理解：

1）限制系统的操作人员不能删除数据、格式化硬盘的功能，那么这个操作员是权限不完备的。

2）手语不能完全表达出一切可以表达的内容，那么手语是表达不完备的。



**4、图灵测试**

1950年，图灵发表了一篇论文，他预测是可能创造出真正智能的可能性的。但什么是“智能”？所以图灵提出的对人类智能的判断标准，和图灵机没有直接关系。简单来讲，就是向机器提问问题，如果30%以上的人不能判断对方是人还是机器，那么这台机器就具备人工智能。这样的一个测试被称为“图灵测试”，测试机器是否能有人类智能的标准。图灵测试是人工智能哲学方面第一个严肃的提案。

所以，也由于图灵在人工智能上的研究和贡献，他被尊称为“人工智能之父”！

**5、图灵原理**

图灵原理的内容是：存在一台抽象的通用计算机，其全部本领包括任何物理上可能的对象所能完成的任何计算。

图灵原理的意义在于，当我们没有找到这样一个通用的计算机或解决模型时，每遇到一个新的问题都需要重新给这个问题搭建模型或制作解决方案。当有这一个通用的计算机时，无论多么复杂的计算机都可以用这样最通用的计算机来进行模拟，那么所以的计算或者测试都是由这个通用计算机来进行实现。

**6、图灵奖**

图灵奖（Turing Award），全称“A.M. 图灵奖（A.M Turing Award）是为了纪念艾伦·图灵的巨大贡献而在1966年设立。是计算机界最知名、最崇高、最广泛认可的奖项，可以称之为“计算机界的奥斯卡奖”。图灵奖对评奖条件要求极高，评奖程序也是非常严格，一般每年只奖励一名计算机科学家，奖励对计算机事业发展做出贡献的人。



#### 三、艾伦·图灵生平

只从这些和图灵相关的概念就可以知道，图灵对计算行业的巨大贡献和他的巨大影响力。其实不止如此，他还是数学家，他解决了困扰数学界30年之久的德国数学家希尔伯特“可计算性与特判定问题”，在数学史上是一个重要的里程碑；在生物学领域，他对复杂系统的自组织问题进行了研究，提出了“生命是如何在混乱的化学汤剂中创造出来的”的问题，直到现在这个问题仍然是前沿学科；在哲学领域，他提出了很多基于人工智能和复杂命题方面的命题直到现在还是哲学家思考和辩论的议题；在物理学领域，他在非线性力学有所贡献；在体育领域，他差一点（由于受伤）就代表英国参加1948年伦敦奥运会参加马拉松比赛；就连他去世前吃掉一小口的苹果，也被苹果公司设置为公司的logo，永远纪念这这位伟大的科学家。



![img](https:////upload-images.jianshu.io/upload_images/5320762-e434eb34988ad7e8.png?imageMogr2/auto-orient/strip|imageView2/2/w/448/format/webp)



艾伦·麦席森·图灵（Alan Mathison Turing）

42岁就陨落的天才科学家

1912年6月23日出生于伦敦城郊

1926年，图灵考入英国著名的谢伯恩公学，在中学时就获得国王爱德华六世数学金盾奖章。

1932年，荣获英国著名的史密斯数学奖。

1936年，图灵写出了论文《论可计算数及其在判定问题中的应用》，证明了希尔伯特提出的“判定性问题”和图灵机的“停机问题”等价，是无法解决的。这是他数学领域最重要数学成果。同时，

1939年他参与英国对德国的密码破译工作。当时，正值第二次世界大战，德国采用了一套称之为“Enigma（谜）”的编制密码的机器。而当时艾伦[·](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5)图灵带领团队对此密码进行破译，帮助盟军来获取德军动态。

1941年艾伦应用图灵图灵机的可计算理论，他们设计了破译机“Ultra”（超越）专门对付德军的“Enigma”，破译了大批德军密码。

1946年，由于他在二战中为破译德军密码做出的巨大贡献，获得“[不列颠帝国勋章](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E4%B8%8D%E5%88%97%E9%A2%A0%E5%B8%9D%E5%9B%BD%E5%8B%8B%E7%AB%A0)”。 

1949年，图灵成为曼切斯特大学（University of Manchester ）计算实验室的副院长，致力研发运行Manchester Mark 1型号储存程序式计算机所需的软件。

1950年图灵发表论文《计算机器与智能》（ Computing Machinery and Intelligence），为后来的人工智能科学提供了开创性的构思。

1950年10月图灵发表了著名论文《机器能思考吗？》，也正是这篇文章，使图灵赢得了“人工智能之父”的桂冠。

1951年，因其同性恋身份曝光，艾伦图灵被指控为“严重猥亵罪”，考虑到其科学贡献，警方予以缓刑，但代价是“化学阉割”以及文章审查。

1954年6月8日，图灵死于家中，死前吃过一口充满氯化钾的毒苹果。

1999年被美国《时代》周刊选为“20世纪最重要的100人”。



**总结：作为计算机之父、人工智能之父的艾伦·图灵为计算行业做出了巨大的贡献，而以他名字的命名的图灵机、图灵完备、图灵测试、图灵奖等等都在计算机行业的各个领域发挥着巨大的作用。在我们学习了解区块链技术的过程中，不可避免会反复接触图灵的相关理论和概念，期待通过这一篇文章能让大家对艾伦·图灵，对图灵的相关概念能有一点了解。**



作者：树哥区块链
链接：https://www.jianshu.com/p/8d879f41e32e
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





# 深入理解图灵机-什么是图灵机、图灵完备

这几年由于区块链的大热，以太坊独特的solidity语言实现智能合约功能，**图灵完备**这个词走进大家的视线。

没有计算机专业知识的同学其实很难理解这个词的意思，其实计算机专业的同学都没有深入理解图灵机，图灵完备，图灵测试等概念包含的内涵。为了方便理解区块链技术，理解智能合约，笔者准备分几篇文章来带大家从浅入深，一步一步带你深入理解图灵机，相信通过这几篇文章能就能够理解什么是图灵完备。

> 大家知道任何伟大艺术的诞生背后都有迷人的时代背景，伟大的科学思想也是一样。从达芬奇到蒙拉丽莎的微笑；从牛顿到万有引力；从爱因斯坦到相对论；伟大的天才图灵和这些大师一样有同样让人着迷的时代和故事。

### 图灵的生平

艾伦·麦席森·图灵（Alan Mathison Turing，1912年6月23日－1954年6月7日），英国数学家、逻辑学家，**被称为计算机科学理论之父，人工智能之父。**

1931年，图灵考入剑桥大学国王学院，由于成绩优异而获得数学奖学金。

1936年5月，年仅24岁的图灵发表一篇题为《论数字计算在决断难题中的应用》的论文，论文中提出一种计算装置，后被称为**“图灵机”**，图灵机不是具体的计算机，而是一种计算概念、计算理论。

1938年在普林斯顿获博士学位，其论文题目为“以序数为基础的逻辑系统”，在数理逻辑研究中产生了深远的影响；同年图灵回到英国，在剑桥大学国王学院任研究员。

第二次世界大战期间，1939年图灵到英国外交部通信处从事军事工作，主要是破译敌方密码的工作。由于破译工作的需要，他参与了世界上最早的电子计算机的研制工作。他的工作取得了极好的成就，破译了德国人Enigma密码，于1945年获政府的最高奖——大英帝国荣誉勋章。



![img](https:////upload-images.jianshu.io/upload_images/10096448-17f4b1ad3b7968f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/519/format/webp)

图灵破解密码

1945年，图灵结束了在外交部的工作，他试图恢复战前在理论计算机科学方面的研究，具体研制出新的计算机来。

1950年他发表论文《计算机器与智能》（ Computing Machinery and Intelligence），为后来的人工智能科学提供了开创性的构思。提出著名的**图灵测试**。

1950年，1950年10月，图灵发表论文《机器能思考吗》。这一划时代的作品，使图灵赢得了“人工智能之父”的桂冠。此时，人工智能也进入了实践研制阶段。随着这几年AI技术的不断成熟，人们越来越认识到图灵思想的深刻性：它们至今仍然是人工智能的主要思想之一。

1954年6月7日，年仅41岁的图灵被发现死于家中的床上，床头还放着一个被咬了一口的苹果。这就是现在大名鼎鼎的苹果电脑公司logo的来源。

### 时代背景

从图灵的生平中，我们知道，他出生在20世纪初，1912年。
 在世界国家格局上，这个时候刚刚爆发第一次世界大战（1913~1921），紧接着1939年至1945年第二次世界大战，大家知道，这两次世界大战倒逼了很多科技的发展，二战期间恰好是图灵青年时代。

在科技文明发展上，由于逻辑的数学化，促使了数理逻辑学科的诞生和发展。但同时这个时期数学上发生了第三次数学危机，具体介绍在下方。图灵在剑桥读大学期间，修读了“数学基础”课程，授课人是纽曼，纽曼整个课程包含对哥德尔不完备性定理的证明和尚未解决的判定性问题。

这些科技事件的背后，其实是人们在认知上，对**可计算性理论**的研究，图灵正是这个问题终结者。

随便提一下，爱因斯坦1905年提出狭义相对论，1927年年仅15岁的图灵为了帮助母亲理解相对论，还写过论文的摘要。

#### 可计算性理论

在20世纪以前，人们普遍认为，所有的问题类都是有算法的，人们的计算研究就是找出算法来。1900年，当时著名的大数学家希尔伯特在世纪之交的数学家大会上给国际数学界提出了著名的23个数学问题。
 其中第十问题是这样的：

> 存在不存在一种有限的、机械的步骤能够判断“丢番图方程”是否存在解？

“丢番图方程”指：有一个或者几个变量的整系数方程，它们的求解仅仅在整数范围内进行。
 上面这个问题简单点解释是：随便给一个不确定的方程，是否通过有限的步骤运算，判断这个方程是否存在整数解。

这个问题在1970年，苏联一个数学家证明了其实很多数学问题，是没有答案，甚至没有答案的问题比有答案的问题还要多。

这里就提出来了有限的、机械的证明步骤的问题，其实就是算法。但在当时，人们还不知道“算法”是什么。实际上，当时数学领域中已经有很多问题都是跟“算法”密切相关的，因而，科学的 “算法” 定义呼之欲出。之后到了30年代的时候，终于有两个人分别提出了精确定义算法的方法，一个人是图灵，一个人是丘奇。而其中图灵提出来的图灵机模型直观形象。

图灵思考这个问题的方式和常人不一样，在写前面提到的论文《论可计算数及其在判定性问题上的应用》的时候，图灵在思考三个问题

> 1. 世界上是否所有的数学问题都有明确的答案？
> 2. 如果有明确的答案，是否可以通过有限步骤的计算得到答案？
> 3. 对于那些有可能在有限步骤计算出来的学习问题，是否有一种假想的机械，让它不断运行，最后机器停下来的时候，那个数学答案就计算出来了？

图灵这样的天才考虑问题的认知是高屋建瓴的。
 图灵首先考虑的是是否所有数学问题都用解，如果这个问题不解决，辛辛苦苦解题，最后发现无解，一切的努力都是浪费时间和精力。

对于存在答案的数学问题，只有部分是可以在有限步骤内完成，这样把计算机的边界确定下来了。

确定了边界之后，就要设计一种通用、有效、等价的机器，保证可以按照这个方法做事，最后得到答案。而图灵机就是图灵设计出来的这样的一个机器，严格来讲是一种数学模型、计算理论模型。

从图灵机提出到现在已经过去了80多年，今天所有的计算机，包括量子计算机都没有超出图灵机的理论范畴。

#### 第三次数学危机与停机问题

第三次数学危机产生于十九世纪末和二十世纪初，当时正是数学空前兴旺发达的时期。首先是逻辑的数学化，促使了数理逻辑这门学科诞生。

早在19世纪末的时候，康托尔为集合论做了奠基性的研究。人们发现，运用集合这个概念可以概括所有的数学，也就是说集合是一切数学的基础。然而就当这座大厦即将完工的时候，一件可怕的事情发生了，罗素提出来的罗素悖论粉碎了数学家的梦想。

关于罗素悖论的一个通俗化版本是：

> “村子里有一个理发师，他给自己定了一条规矩：‘不给那些所有给自己理发的人理发’。
>  现在就要问，这个理发师该不该给自己理发？”。
>  如果你尝试回答这个问题就会发现奇怪的事情：这个问题本身似乎是不可能的！

为什么要第三次数学危机呢？
 因为有个很重要的概念：**停机问题**，停机问题是逻辑数学中可计算性理论中很重要的问题，也是第三次数学危机的解决方案。
 **停机问题**通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。

有人猜测图灵机模型是图灵在思考**停机问题**而顺带设计出来的，是很有道理的。

### 人工智能

图灵在剑桥大学国王学院期间，研究过一本叫做《量子力学的数学基础》的新书，这本书由年轻的匈牙利数学家约翰·冯·诺依曼所著。图灵意识到计算可以用确定性的机械运动来进行表示。其实我们现在的电子计算机虽然不是我们传统意义上的机械，但是CPU内部的电子运动等价于机械运动。

同时图灵也意识到人的思想、意识来自于量子力学中的测不准原理，这不光是微观世界，同时也是这个宇宙本身的规律。所以图灵意识到计算是确定性的，可判定的，而意识是不定的，不可计算的。

在AI人工智能有巨大发展的今天，很多人担心计算机是否会和人一样有意识，其实图灵在80多年前已经考虑过这个问题了。

前面提到，图灵在1950年写过一篇论文《计算机器与智能》，在这篇论文中，图灵测试一词被提出来：

> 指测试者与被测试者（一个人和一台机器）隔开的情况下，通过一些装置（如键盘）向被测试者随意提问。进行多次测试后，如果有超过30%的测试者不能确定出被测试者是人还是机器，那么这台机器就通过了测试，并被认为具有人类智能

这个测试有多难？目前我们所有的人工智能都没有完成这个测试。最近2018年3月份的谷歌I/O大会上演示的AI产品，据说“部分通过图灵测试”。这个部分到底有多少也未可知。

### 总结与启示

从人类科技发展的历史上来看，19世纪末到20世纪中期，是第二次工业革命和第三工业革命过渡的时期。第二次工业革命主要电和磁、内燃机的发明和使用，发展到这个时候科学家对世界的认知越来越多，越来越清晰，物理学和数学等自然科学发展迅速。这个时候的数学家发现很多现象可以用数学模型来表示，从物体的运动到星球的运动、从热能到动能的转换、从电到磁的转换等等。那问题来了是否所有的现象都可以用数学模型来表达呢？真是这个问题，让人们对数学很多根本性问题进行思考和研究。

中国有句古话说：乱世出英雄。在图灵的时代，在科学历史上出了很多的科学英雄，包括爱因斯坦、冯诺依曼、图灵、哥德尔等等，一方面是时代背景使然，一方面真是他们的天赋和努力让以信息化为代表的第三次工业革命的进程大大加快了。

从这些巨匠的思考问题，解决问题的方法和认知来看是超出常人的。从对**可计算性理论**的思考，给了我们很大的启示：

1. 要学会抽象，看问题高屋建瓴，学会从上帝视角看问题
2. 知道做事情的边界是非常重要的，可以指导人们在正确的范围内做事情，可以减少很多无谓的付出。
3. 做事情要有方法论，理解计算的等价性
4. 要学好数学

------

**更多有关区块链的技术与思维，可扫码加入我的小密圈。在这里，我陪着你，大家一起研究区块链技术，探讨区块链思维，预测区块链未来，一起做未来前10%的人



作者：jerry的技术与思维
链接：https://www.jianshu.com/p/3817b9d5ff76
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 理解图灵机--什么是图灵机、图灵完备

[上一篇](https://www.jianshu.com/p/3817b9d5ff76)介绍了天才图灵所做的时代背景，我们了解那个时代对于数学逻辑，可计算理论的发展。站在更大的时间和空间维度来看，我们看问题的角度会有更高的视角。

**这篇我们来具体看下图灵机到底是什么？**

从[上一篇文章](https://www.jianshu.com/p/3817b9d5ff76)我们知道图灵机首次提出在图灵的一篇论文《论数字计算在决断难题中的应用》中提出，原论文题目为《On Computable Numbers, with an Application to the Entscheidungsproblem》，英文好的同学可以从[https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cs.virginia.edu%2F~robins%2FTuring_Paper_1936.pdf) 这个链接中查看原版的论文内容。

## 一、图灵机的组成

网上有一张经典的图片来表达图灵机的构成，图如下：



![img](https:////upload-images.jianshu.io/upload_images/10096448-abc29bec5d9d24e7.png?imageMogr2/auto-orient/strip|imageView2/2/w/410/format/webp)

图灵机的组成.png

> 这张图片什么意思？这么一个简单的机器/装置怎么会所有电子计算机的理论模型？

相信大家看到这张图后都有这样的疑问，下面笔者带来由浅入深去理解图灵机的组成。
 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，它运算过程看作下列两种简单的动作：

- 在纸上写上或擦除某个符号；
- 把注意力从纸的一个位置移动到另一个位置；

逻辑结构上图灵机有四个部分组成

1. 一个无限长的存储带，带子有一个个连续的存储格子组成，每个格子可以存储一个数字或符号
2. 一个读写头，读写头可以在存储带上左右移动，并可以读、修改存储格上的数字或符号
3. 内部状态存储器，该存储器可以记录图灵机的当前状态，并且有一种特殊状态为**停机状态**
4. 控制程序指令，指令可以根据当前状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作（左移还是右移），并改变状态存储器的值，令机器进入一个新的状态或保持状态不变。

当然这些只是理想的图灵机，因为现实中不存在无限长的存储带，更加图灵的理论这样的一台装置就能模拟人类所能进行的任何计算过程。是不是很神奇？我相信你肯定不相信，不过图灵是经过严格的数学证明，下面我们来看看图灵机的计算过程。

## 二、图灵机的运行机制

**图灵机工作步骤**

1. 准备



```undefined
      - 存储带子上的格子初始话
      - 设置内部状态存储器当前状态
      - 读写头设置初始在存储带上所做的格子位置
      - 准备好控制指令，即控制程序。
```

1. 反复执行以下步骤，直到停机



```undefined
 - 读写头读出当前格子的数字或符号
 - 根据当前状态和读到的字母或符号找到对应的控制指令
 - 根据控制指令，执行以下三个动作
    1. 读写头在格子上擦除或写入一个数字或符号
    2. 变更状态到一个新状态
    3. 读写头向左或向右移动一格
```

估计你还是不明白，别急。看过《三体》的同学都知道三体人把地球人看做**“虫子”**，三体人的维度比地球三维世界高，就好像我们人类把看虫子一样。
 下面，我们把虫子放到一个二维的世界中，以虫子为例，给大家来说明最简单的图灵机模型（注：该例子非原创）。

#### 假设理想的情况一：

1. 虫子所处的二维世界是一个无限长的纸带，这个纸带上被分成了若干小的方格，而每个方格都仅仅只有黑和白两种颜色。纸带的片段为：

   ![img](https:////upload-images.jianshu.io/upload_images/10096448-7e75b2727b3f90d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/817/format/webp)

   虫子所在二维纸带.png

2. 假设虫子的感官只有眼睛，并且它的视力短的可怜，只能看到当前所处格子的颜色

3. 虫子可以向前爬一个格子或向后爬一个格子

4. 虫子的操作系统、程序为：我们假设黑色是食物区，虫子吃到食物后前移一格，白色是空白区，没有食物后退一格，

| 输入 |     输出 |
| ---- | -------: |
| 黑色 | 前移一格 |
| 白色 | 后移一格 |

在这个情况中格子的颜色是虫子的输入信息，集合为IN={黑色，白色}，输出集合为 OUT= {前移一格，后移一格}
 从开始位置开始，虫子会怎么移动呢？

1. 开始是黑色，虫子前移一格，到达第2格
2. 第2还是黑色，虫子前移一格，到达第3格
3. 第3格还是黑色，虫子前移一格，到达第4格
4. 第4格为白色，虫子后移一格，回到第3格
5. 可见，这条带子上，虫子在第4格和第3格来回移动循环不止。

##### 假设理想的情况二

现实中虫子肯定不可能傻到无线循环，虫子会有饥饿、吃饱的感受，食物吃了后也会消失。因此我们在情况下中改进下模型。

1. 虫子在黑色的格子时，如果是饥饿状态，吃掉食物把格子变成白色；如果是吃饱状态，后移一格
2. 虫子在白色的格子时，如果是饥饿状态，停下来等食物长出来涂黑；如果是吃饱状态，前移一格
3. 虫子的操作系统、程序为：

| 输入 | 当前状态 |                         输出 | 下一个状态 |
| ---- | -------: | ---------------------------: | ---------: |
| 黑色 |     吃饱 |                     后移一格 |       饥饿 |
| 黑色 |     饥饿 |   吃完食物格子变白（不移动） |       吃饱 |
| 白色 |     吃饱 |                     前移一格 |       饥饿 |
| 白色 |     饥饿 | 等待食物长出来涂黑（不移动） |       吃饱 |

在这种情况中，输入集合为IN={黑色，白色}，输出集合为 OUT= {前移一格，后移一格，吃掉食物涂白，等待食物长出来涂黑}，内部状态S={吃饱，饥饿}

二维纸带不变，从开始位置开始，**虫子初始是饥饿状态**，虫子会怎么移动呢？

1. 第1格是黑色，虫子饥饿，吃掉食物格子变白，虫子新状态为吃饱
2. 第1格为白色，虫子吃饱，虫子前移一格，到达第2格，虫子新状态为饥饿
3. 第2格为黑色，虫子饥饿，吃掉食物格子变白，虫子新状态为吃饱
4. 第2格为白色，虫子吃饱，虫子前移一格，到达第3格，虫子新状态为饥饿
5. 第3格为黑色，虫子饥饿，吃掉食物格子变白，虫子新状态为吃饱
6. 第3格为白色，虫子吃饱，虫子前移一格，到达第4格，虫子新状态为饥饿
7. 第4格为白色，虫子饥饿，等待食物长出来涂黑，虫子新状态为吃饱
8. 第4格为黑色，虫子吃饱，虫子后退一格，到达第3格，虫子新状态为饥饿
9. 这时，第3格已经长出来食物，是黑色，因此流程和第5步的情况一样了

情况二，小虫的行为比情况以复杂了一些，但小虫最后仍然会落入无限循环当中。

> 到此，如果你已经彻底搞懂了二维虫子是怎么移动的，那么你已经明白了图灵机的工作原理了！因为从本质上讲，最后的小虫模型就是一个图灵机！

### 三、如何理解图灵机

刚才用二维虫子说明了图灵机的工作原理，相信你的第一个反映就是，这样的模型太简单了！
 他根本说明不了现实世界中的任何问题！下面，我就要试图说服你，图灵机这个模型是伟大的！

其实虫子的所有决策和行为都可以抽象成一个图灵机模型。

为什么可以做这种抽象呢？
 其实可以把二维虫子的模型进行更多扩展，以和现实世界基本或完全一致。因为二维虫子模型是以一切都简化的前提开始的，所以它的确是太太简单了。

然而，我们可以把二维虫子的输入集合、输出行动集合、内部状态集合进行扩大，这个模型就一下子实用多了。

1. 二维虫子完全可以处于一个三维的空间中而不是简简单单的纸带。
2. 二维虫子的视力很好，它一下子能读到方圆500米的信息。
3. 二维虫子也可以拥有其他的感觉器官，比如嗅觉、听觉等等，而这些改变都仅仅是扩大了输入集合的维数和范围，并没有其他更本质的改变。
4. 二维虫子可能的输出集合也是异常的丰富，它不仅仅能移动自己，还可以尽情的改造它所在的自然界。
5. 进一步的，二维虫子的内部状态可能非常的多，而且控制它行为的程序可能异常复杂

那么二维虫子会有什么本事呢？这就很难说了，因为随着小虫内部的状态数的增加，随着它所处环境的复杂度的增加，我们正在逐渐失去对二维虫子行为的预测能力。

> 但是所有这些改变仍然没有逃出图灵机的模型：
>  **"输入集合、输出集合、内部状态、固定的程序指令！"**
>  就是这四样东西抓住了二维虫子信息处理的根本。

### 四、 什么是图灵完备

维基百科解释：

> 可图灵指在可计算性理论中，编程语言或任意其他的逻辑系统如具有等用于通用图灵机的计算能力。换言之，此系统可与通用图灵机互相模拟。

上面的解释比较抽象，通过上面的例子理解了什么是图灵机，图灵完备其实就很很简单理解了。

> 简单来说，能够抽象成图灵机的系统或编程语言就是图灵完备的；一切可计算的问题图灵机都能计算，因此满足这样要求的逻辑系统、装置或者编程语言就叫图灵完备的。

因此可见，二维虫子是图灵完备的。

Bitcoin的脚本由于没有条件分支，循环等控制指令，回到上面的虫子的例子，虫子就不能根据当前状态，判断选择移动还是吃食物等一系列的动作，因此不满足图灵机的模型，不是图灵完备的。

### 五、人也是图灵机？



![img](https:////upload-images.jianshu.io/upload_images/10096448-e21c25ff18461a6e.png?imageMogr2/auto-orient/strip|imageView2/2/w/557/format/webp)

大脑操作系统.png


 我们人能不能也被这样的抽象呢？**显然是可以的。**



其实我们每一个会决策、会思考的人就可以被抽象的看成一个图灵机，也就是笑来老师一直说：每个人都有自己的操作系统，因为有元认知能力，还可以自己升级操作系统。

输入状态集合就是你所处的环境中能够看到、听到、闻到、感觉到的所有一起，可能的输出集合就是你的每一言每一行，以及你能够表达出来的所有表情动作。内部状态集合则要复杂得多。因为我们可以把任意一个神经细胞的状态组合看作是一个内部状态，那么所有可能的神经细胞的状态组合将是天文数字！这就是人类的记忆。只要图灵机具有了内部状态，它就相应的具有了记忆。

这样理解的话，还有两个问题：

1. 图灵机的程序指令是固定的。但是人类有学习能力，也就是说人的大脑会进化，操作系统会升级，所以大脑的实际程序规则是不固定，似乎图灵机模型包含不了。
2. 人类的很多现象似乎都能被图灵机包括：情绪、情感等

这个问题，其实图灵也已经考虑过了，其实就是我们现在一个大热门：AI，人工智能，计算机是否真的能实现人工智能。下一篇我们讲和大家聊聊这个话题。



作者：jerry的技术与思维
链接：https://www.jianshu.com/p/c07d83c4f3a1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 神经图灵机 Neural Turing Machine-DeepMind

> Neil Zhu，简书ID Not_GOD，University AI 创始人 & Chief Scientist，致力于推进世界人工智能化进程。制定并实施 UAI 中长期增长战略和目标，带领团队快速成长为人工智能领域最专业的力量。
>  作为行业领导者，他和UAI一起在2014年创建了TASA（中国最早的人工智能社团）, DL Center（深度学习知识中心全球价值网络），AI growth（行业智库培训）等，为中国的人工智能人才建设输送了大量的血液和养分。此外，他还参与或者举办过各类国际性的人工智能峰会和活动，产生了巨大的影响力，书写了60万字的人工智能精品技术内容，生产翻译了全球第一本深度学习入门书《神经网络与深度学习》，生产的内容被大量的专业垂直公众号和媒体转载与连载。曾经受邀为国内顶尖大学制定人工智能学习规划和教授人工智能前沿课程，均受学生和老师好评。

> **作者**:
>  Alex Graves [gravesa@google.com](https://link.jianshu.com?t=mailto:gravesa@google.com)
>  Greg Wayne [gregwayne@google.com](https://link.jianshu.com?t=mailto:gregwayne@google.com)
>  Ivo Danihelka [danihelka@google.com](https://link.jianshu.com?t=mailto:danihelka@google.com)
>  Google DeepMind, London, UK

原文：[http://arxiv.org/pdf/1410.5401.pdf](https://link.jianshu.com?t=http://arxiv.org/pdf/1410.5401.pdf)

[gitbook 链接](https://link.jianshu.com?t=https://tigerneil.gitbooks.io/deep-learning-researchers/content/neural_turing_machine.html)

> 悠长的历史会让人迷失在巨大的信息中，所以直接从第三节开始给出神经图灵机的介绍、解释和实验分析。

# 3 神经图灵机

神经图灵机包含两个基本组成部分：神经网络控制器和记忆库。

![img](https:////upload-images.jianshu.io/upload_images/42741-cbb6ca0430e1239d.png?imageMogr2/auto-orient/strip|imageView2/2/w/744/format/webp)

神经图灵机

控制器通过输入输出向量和外界交互。不同于标准神经网络的是，控制器还会使用选择性的读写操作和记忆矩阵进行交互。类比于图灵机，我们将网络的参数化这些操作的输出称为“读头”。
 最关键的是，每个组成部分都是可微的，这样可以更加直接地使用梯度下降进行训练。我们通过定义�模糊的读写操作根据一个更高或者更低的度（degree）和的记忆中的所有元素进行交互（而不是像在正常的图灵机或者数字计算机那样一次只是处理一个单个的元素）。这个模糊的度由一种注意力聚焦机制确定，将每个读写操作限制在记忆中的一小块上，忽略其他部分。因为和记忆的交互是高度稀疏的，NTM 倾向于无干扰地存储数据。进入注意力聚焦的记忆位置由读头特定的输出确定。这些输出定义了一个规范化的权重在记忆矩阵的行上（对应于内存位置）。每个权重，对应于一个读头或者写头，定义了在每个位置读写的程度。读头可以在单个位置相当重视或者分散精力在若干位置。

## 3.1读

令 $$M_t$$ 为 $$N\times M$$ 在时间 $$t$$ 的记忆矩阵，其中 $$N$$ 是记忆位置的数目，而 $$M$$ 是每个位置的向量的大小。令 $$\mathbf{w}_t$$ 是在时间 t 一个读头输出的在 N 个位置上的向量。因为所有权重都是规范化的，$$\mathbf{w}_t$$ 的 N 个元素 $$w_t(i)$$ 遵循下面的限制：

![img](https:////upload-images.jianshu.io/upload_images/42741-5197debc5a7a1848.png?imageMogr2/auto-orient/strip|imageView2/2/w/532/format/webp)

由读头返回的长度为 $$M$$ 的读向量 $$r_t$$ 定义成一个记忆中行向量 $$M_t(i)$$ 凸包:

![img](https:////upload-images.jianshu.io/upload_images/42741-0ff096e757239cd9.png?imageMogr2/auto-orient/strip|imageView2/2/w/475/format/webp)

这显然是对记忆和权重都是可微的。

## 3.2 写

受到 LSTM 中的输入和忘记门的启发，我们将每个写操作分解成了两个部分：消除和添加：erase + add。

给定在时间 t 写头输出的权重 w_t，跟上一个消除向量 e_t 其中 M 个元素都是在 (0,1) 之内的，来自前一个时间步记忆向量 M_{t-1}(i) 做出如下修改：

![img](https:////upload-images.jianshu.io/upload_images/42741-ab369784d51af599.png?imageMogr2/auto-orient/strip|imageView2/2/w/512/format/webp)



其中 $$\mathbf{1}$$ 是元素都是 $$1$$ 的行向量，按点进行每个记忆位置的乘法。因此，记忆位置的元素重置为 0 如果在位置处的权重和消除元素都是 1；如果两个中有一个为 0，记忆就保持不变。当多个写头给出了，消除操作可以按照任意的顺序进行，因为乘法实际上是可交换的。

每个写头同样还会产生一个长度为 M 的加法向量 a_t，这个会在每个消除步执行后被加到记忆中：

![img](https:////upload-images.jianshu.io/upload_images/42741-d4cec6a2dda20e42.png?imageMogr2/auto-orient/strip|imageView2/2/w/483/format/webp)

另外，多个头进行的加法操作的顺序是不相关的。所有写头上的消除和添加操作产生了在时间 $$t$$ 最终的记忆内容。由于消除和添加操作都是可微的，符合写操作就也是可微的了。注意到，消除和添加向量有 $$M$$ 个独立的部分，这样可以更好地控制在每个内存位置上的那些需要修改的元素。

## 3.3 寻址机制

尽管我们已经展示了读写操作的方程，还没有描述权重如何产生。这些权重是通过合并两个寻址机制产生的。第一个机制，“基于内容的寻址”，将注意力集中在基于当前值和控制器产生的值之间的相似度来确定的位置上。这和 Hopfiled 网络的基于内容寻址方式是相似的。（Hopfield 1982）这样的好处是检索变得简单，仅仅需要控制器去产生存储数据的部分的近似，然后这个值会和内存进行比较从而产生准确的存储值。

然而，不是所有的问题都是适合基于内容的寻址的。在某些任务中，变量的内容是任意的，但是变量仍然需要可识别的名称或者地址。算术问题就属于这一类：变量 $$x$$ 和变量 $$y$$ 可以用两个值作为输入，但是过程 $$f(x,y) = x \times y$$ 仍然需要定义。对该任务的控制值需要以 $$x$$ 和 $$y$$ 作为输入，将他们存放在不同的地址中，然后对他们进行检索，并执行乘法算法。这种情形下，变量通过地址进行检索，而不是内容。我们将这种类型的寻址称为“基于地址的寻址”。基于内容的寻址严格上比基于地址的寻址更加一般，因为内存地址中的内容可以包含地址的信息。不过在我们的实验中，提供基于地址的寻址作为原语曹组可以对某些形式的泛化更加有效（essential），所以我们将两种机制同时采用了。

图 2 展示了整个寻址系统的流程图，包含了在读或者写的时候构造一个权重向量的操作的顺序。

![img](https:////upload-images.jianshu.io/upload_images/42741-8878321e9892a825.png?imageMogr2/auto-orient/strip|imageView2/2/w/755/format/webp)

图 2

### 3.3.1 通过内容聚焦

对基于内容寻址，每个读头（用在读或者写上）首先会产生一个长度为 M 的 *key vector* $$k_t$$，这个会和每个向量 $$M_t(i)$$ 通过相似性度量 $$K[\dot,\dot]$$ 进行比较。基于内容的系统产生了一个正规化的权重 $$w_t^c$$ 基于相似度和正的 **key strength** $$\beta_t$$，这个可以扩大或者减少聚焦（focus）的准确度：

![img](https:////upload-images.jianshu.io/upload_images/42741-c0e0e6e7adb3d321.png?imageMogr2/auto-orient/strip|imageView2/2/w/570/format/webp)

在我们现在的实现中，相似性度量就是余弦相似度：

![img](https:////upload-images.jianshu.io/upload_images/42741-43f3b39d8467b115.png?imageMogr2/auto-orient/strip|imageView2/2/w/483/format/webp)

### 3.3.2 通过位置聚焦

基于位置的寻址机制为了利用在内存的空间上进行简单的迭代和随机访问跳跃的好处。这是通过一个权重的旋转变换来实现的。例如，如果当前权重聚焦在一个单个位置上，$$1$$ 的旋转将会聚焦到下一个位置。而一个负的变换则会将权重聚焦到相反的方向上。

在旋转前，每个读头产生一个标量的 *interpolation gate* $$g_t$$，其值在 $$(0,1)$$ 内。$$g$$ 的值被用来在前一个时间步读头产出的权重 $$w_{t-1}$$ 和在当前时间步内容系统的产出的权重 $$w_t^c$$ 之间进行合成（blend）得到 *gated weighting* $$w_t^g$$：

![img](https:////upload-images.jianshu.io/upload_images/42741-b5527e41331c3cb3.png?imageMogr2/auto-orient/strip|imageView2/2/w/497/format/webp)

如果这个 *gate* 是 $$0$$，那么内容权重就整个被忽略了，就会使用前一时间步的权重。相反，如果 *gate* 是 $$1$$，来自前一步的权重就完全被忽略了，整个系统就使用了基于内容的寻址。

在 interpolation 之后，每个读头产生一个 *shifting* 权重 $$s_t$$，在所有允许的整数偏移上的定义了一个正规化的分布。例如，如果在 $$-1$$ 到 $$1$$ 之间的 shifting 权重被允许，$$s_t$$ 就有是哪个元素对应于偏移的程度 $$-1$$，$$0$$ 和 $$1$$。定义偏移权重的最简单的方式就是使用一个在跟控制器相关的合适大小 softmax 层。我们还实验了另一种技术，其中控制器产生一个单个标量被解释为一个在偏移上的均匀分布的宽度下界。例如，如果偏移变量是 $$6.7$$，那么 $$s_t(6) = 0.3$$，$$s_t(7) = 0.7$$，剩下的就是 $$s_t = 0$$。

如果我们将 $$N$$ 个内存位置索引为 $$0$$ 到 $$N-1$$，那么通过 `s_t` 应用在 `w_t^g` 上的选择可以按照下面的 circular 卷积表示：

![img](https:////upload-images.jianshu.io/upload_images/42741-c78d82014e94e79a.png?imageMogr2/auto-orient/strip|imageView2/2/w/492/format/webp)

其中所有的索引算术都是进行了模 $$N$$ 处理。在偏移权重不很平缓时，卷积操作可能会随时间产生权重的丢失或者发散（leakage or dispersion）例如，如果偏移 -1 0 1 给定了权重 0.1 0.8 0.1，那么旋转将会转换权重聚焦在一个单一的点变成三个点上的模糊不清。为了避免这个情况，每个读头产生一个另一个标量 $$\gamma_t\geq 1$$，其作用就是将最终的权重变得更加的陡峭：

![img](https:////upload-images.jianshu.io/upload_images/42741-2b20b4722bda3da1.png?imageMogr2/auto-orient/strip|imageView2/2/w/467/format/webp)

权重 interpolation 和基于内容及地址机制合并的寻址系统可以以三种互补方式执行。第一，权重可以通过内容系统选出而不需要位置系统的支持。第二，通过内容寻址系统产生的权重可以被选择然后进行偏移。这使得聚焦可以跳到紧邻的下一个位置，但是不能够跳到由内容获取的位置；用计算机科学术语就是这允许读头找到连续的数据块，并在这个块中获取一个特定的元素。第三，来自前一个时间步的权重可以不用任何基于内容寻址系统的输入进行旋转。这可以让权重可以通过一系列的寻址在每个时间步增加同样的距离进行。

## 3.4 控制器网络

上面描述的神经图灵机架构有几个自由参数，包括内存的大小，读写头的数量和允许的位置偏移的范围。但是可能表现最好的选择是将神经网络作为控制器。特别地，我们需要确定是否使用一个循环或者前驱神经网络。诸如 LSTM 这样的循环控制器有其本身的内存，可以作为矩阵中更大的内存的补充。如果我们将此控制器和计算机的中央处理器，将内存矩阵和 RAM 进行对比，那么循环神经网络的控制器的隐藏层激活就和处理器重的多个时间步相关了。他们可以用控制器来混合多个时间步的信息。另一方面，前驱控制器可以通过在每一步内存中进行读写模仿一个循环网络。甚至，前驱控制器常常能给出更大的网络操作的透明度，因为从内存矩阵中读出和写入到内存矩阵通常比一个循环神经网络的内部状态更容易解释。然而，前驱控制器的一个缺点就是并发读和写头会产生NTM的计算瓶颈。使用单一的读头，就只能执行一个在每个时间步对单个的内存向量进行一元变换，两个读头则可以进行双向量变换，如此类推。循环控制器可以内部存储前一个时间步的读向量，所以不会受到这个的限制。

# 4. 实验

本节给出一些基本的实验，在一些简单算法任务上，例如数据的复制和排序。不仅仅是为了展示 NTM 能够解决这些问题，而且说明了 NTM 能够通过学习紧致的内部程序。这些解决方案的特点是他们可以超越训练数据的界限。例如，我们很好奇如果一个网络已经学会了复制 20 长度的序列，是不是它就可以复制长度 100 的序列，而不需要额外的训练。

对所有的实验，我们比较了三个架构：使用前驱控制器的 NTM，LSTM 控制器的 NTM 和标准的 LSTM 网络。因为所有任务都是按阶段的，我们就在每个输入序列的开始重置了网络的动态状态。对 LSTM 网络，这种设置下前一时间步的隐藏状态就是一个学到的偏差向量。对 NTM 控制器的前一个状态，前一阶段读出的向量，和内存的内容都会重设置为偏差值。所有这些任务都是监督学习问题，其目标是二元的；所有网络都是 logistic sigmoid 输出层并且使用了 cross-entropy 目标函数训练。序列预测误差按照 bits-per-sequence 进行汇报。更多细节参见 4.6 节的实验参数。

## 4.1 复制

复制任务测试 NTM 是否能够存储和复现一个任意信息的长序列。网络会用随机二元向量作为输入序列，并跟上一个分隔符。对长期时间段的信息的存储和获取是循环神经网络和其他一些动态架构的弱项。我们特别想知道 NTM 是不是能够比 LSTM 更好地衔接更长的时间间隔。

网络训练复制 8 个bit 的随机向量，其中序列长度是 1 到 20 之间随机值。目标序列简单就是输入序列的副本（不含有分隔符）注意在网络接收到目标时，并没有输入给网络，这样保证它可以不要任何帮助回忆起整个序列。

正如在图 3 中展示的那样，NTM（用前驱或者 LSTM 控制器）比单单的 LSTM 学得更快，并且收敛到一个更低的代价上。而 NTM 和 LSTM 学习曲线之间的明显差距也给出了一个可以定性分析两个模型解决这个问题方式的不同。

![img](https:////upload-images.jianshu.io/upload_images/42741-2a328edf8960360a.png?imageMogr2/auto-orient/strip|imageView2/2/w/607/format/webp)

图 4

![img](https:////upload-images.jianshu.io/upload_images/42741-fb814cad9df086c3.png?imageMogr2/auto-orient/strip|imageView2/2/w/606/format/webp)

图 5

我们同样研究了这些网络泛化到更长序列的能力。图 4 和图 5 展示了 LSTM 和 NTM 在这个设置下的行为差异巨大。NTM 在长度增加时还能够复制，不过 LSTM 在超过 20 长度后迅速变差。

![img](https:////upload-images.jianshu.io/upload_images/42741-eeca1b5ad6944100.png?imageMogr2/auto-orient/strip|imageView2/2/w/628/format/webp)

图 6

前面的分析说明和 LSTM 不同 NTM它已经学到某种形式的复制算法。为了确定这种算法是怎么样的，我们检查了控制器和内存之间的交互，见图 6。我们相信操作序列可以被下列伪代码总结：

> **initialise**: move head to start location
>
> **while** input delimiter not seen do
>
> - receive input vector
> - write input to head location
> - increment head location by 1
>
> **end while**
>  return head to start location
>
> **while** true **do**
>
> - read output vector from head location
> - emit output
>    *increment head location by 1
>
> **end while**

这实际上就是一个人类程序员在低级程序设计语言上执行同样任务的方式。用数据结构的术语看，我们可以说 NTM 已经学会了如何创建和数据迭代。注意算法合并了基于内容的寻址（跳到序列的开始）和基于位置的寻址（在序列上进行移动）。同样要注意不增加从前一个读写权重相对偏移的能力迭代可能不会推广到长的序列（公式 7） 以及不使用聚焦增陡（sharpening）机制（公式 9）权重可能就随时间丢失精度了。

## 4.2 重复复制

重复复制任务以输出复制的序列指定次数并输出一个序列终止符作为复制任务的扩展。我们进行这个实验的动机是想看看 NTM 是否可以学习一个嵌套的函数。理想目标是，我们希望它可以执行一个 `for` 循环，包含任意已经学到的子过程。

网络接受了随机长度的随机二元向量序列，跟随一个标量值表示复制的次数，使用一个分开的输入信道进行。为了在正确的时间输出终止标志网络必须能够解释额外的的输入并保存已经进行过了的复制次数。和复制任务类似，在初始化序列和复制数目之后并没有其他输入给网络。网络训练的目标是重新产生长度为 $$8$$ 的随机二元向量，其中序列长度和复制次数都是从 $$1$$ 到 $$10$$ 之间随机选择的。代表重复次数的输入被正规化为均值为 $$0$$ 方差为 $$1$$。

![img](https:////upload-images.jianshu.io/upload_images/42741-c5ac423842c05962.png?imageMogr2/auto-orient/strip|imageView2/2/w/401/format/webp)

图 7

![img](https:////upload-images.jianshu.io/upload_images/42741-35be2e761c7f14c0.png?imageMogr2/auto-orient/strip|imageView2/2/w/621/format/webp)

图 8

![img](https:////upload-images.jianshu.io/upload_images/42741-c1b861e636419ff9.png?imageMogr2/auto-orient/strip|imageView2/2/w/626/format/webp)

图 9

图 7 展示了 NTM比 LSTM 在这个任务上学习得更快，但是都是能够很好地解决这个问题。其中这两个架构的差异就是在让进行更加泛化的任务时变得明显了。我们这里考量了两个维度的泛化：序列长度和重复数目。图 8 分别对 NTM 和 LSTM 解释了前者 2 倍的效果及后后者 2 倍的效果。LSTM 在这两种情形下都出问题了，NTM 对更长的序列也是有效的，并且可以执行超过 10 次的重复；不过 NTM 不能够保持自己已经完成了多少次重复，没有能够正确预测正确的终止符。这可能是数值表示重复次数的后果，因为这样不能够轻易地进行超过一个固定长度的泛化。

图 9 给出了 NTM 学到一个在前一节中复制算法的简单扩展，其中序列化读取重复了足够多次。

## 4.3 关联回忆

前面的任务展示了 NTM可以应用算法到相对简单、线性数据结构上。下一个复杂性就出现在带有指针的数据结构上——其中的项指向另一个。我们测试了 NTM 学习这类更加有趣的结构的实例上，通过构造一个项目的列表是的查询其中一个项目需要网络返回后续的项目。更加细节地说，我们定义一个项目作为二元向量的序列，通过左右终止符来进行限制。在几个项目已经被传递给网络后，我们通过展示一个随机的项目进行查询，我们让网络产生这个项目后面的一个。在我们的实验中，每个项目包含三个 6 bit 的二元向量（总共就是 18 bit 每项目）。在训练的时候，我们使用最小 2 项目和最大 6 个项目在每个阶段（episode）。

![img](https:////upload-images.jianshu.io/upload_images/42741-db31038aae3b7d1d.png?imageMogr2/auto-orient/strip|imageView2/2/w/513/format/webp)

图 10

![img](https:////upload-images.jianshu.io/upload_images/42741-c55884631f701a20.png?imageMogr2/auto-orient/strip|imageView2/2/w/624/format/webp)

图 11

图 10 展示了 NTM 比 LSTM 学习的速度明显快很多，在接近 30,000 episode 的时候接近 0 的代价，而 LSTM 并没有在 100 万 episode 后达到 0 的代价。另外，采用前驱控制器的 NTM 比使用 LSTM 控制器的 NTM 学习的速度更加快。这两个结果表明 NTM 的外存的确是比 LSTM 的内部内存更加有效的一种维持数据结构的方式。NTM 同样比 LSTM 在更加长的序列上泛化得更好，可以在图 11 中看到。使用前驱控制器的 NTM 对 接近 12个项目的情形下接近完美的效果（两倍于训练数据的最大长度），仍然有低于 15 个项目的序列每序列 1 bit 的平均代价。

![img](https:////upload-images.jianshu.io/upload_images/42741-d6b47b0acb71e13c.png?imageMogr2/auto-orient/strip|imageView2/2/w/622/format/webp)

图 12

在图 12 中，我们展示了在一个单个测试 episode 通过一个 LSTM 控制读头的 NTM 内存操作。在“�Inputs”中，我们看到输入代表项目的分隔符在第 7 行作为单一的 bit。在项目的序列已经进行传递后，在第 8 行的一个分隔符让网络准备接受一个查询项目。这里，查询项目对应于在序列中（在绿色盒子中）的第二个项目。在“�Outputs”中，我们看到了网络给出了输出在训练中的项目 3 （在红色盒子中）。在“读取权重”中，在最后三个时间步，我们看到控制器从连续位置上读取了项目 3 的时间分片。这非常奇怪，因为这看起来网络已经直接跳到了正确的存储项目 3 的位置。然而，我们可以解释这个行为通过看“写权重”。这里我们发现，内存甚至在输入给出了一个分隔符的时候进行了写操作。我们可以在“Add”确认这个数据实际上在给定分隔符的时候已经写入内存（比如，在黑色盒子中的数据）；而且，每次分隔符出现，加入到内存中的向量是不同的。更多的分析揭示出网络在通过使用基于内容的查找获得了器读取后相应的位置移动一位的位置。另外，使用内容查找的 key 对应于添加到这个黑色盒子的向量。这其实表示了下面的算法：在每个项目分隔符给出的时候，控制器写一个该项目的前三个时间片压缩的表示。在查询过来时，控制器重新计算同样的查询的压缩表示，使用基于内容的查找来获得第一次写表示的位置，然后偏移 1 位来产生后续的序列中的项目（这样就把基于内容的查找和基于位置的偏移结合起来了）。

## 4.4 动态 N-Grams

动态 N-Grams 任务的目标就是测试 NTM 是否可以快速适应新的预测分布。特别地，我们对 NTM 是否能使用其内存作为一个重写的表，可以用来保存变换统计的数量，因此来衡量传统的 N-Gram 模型。
 我们考虑所有可能的在二元序列上的 6-Gram 分布。每 6-Gram 分布可以被表示成一个 $$2^5 = 32$$ 个数字的表，表示了在给定所有可能的长度为 5 的二元历史序列时下一个 bit 为 1 的概率。对每个训练样本，我们首先通过独立地从 $$Beta(\frac{1}{2},\frac{1}{2})$$ 中采样所有 32 个概率产生随机的 6-Gram 的概率。

我们然后使用当前的查找表通过采样 200 个按 bit 顺序产生的特殊的训练序列。这个网络一次看序列的一个 bit，然后被询问预测下一个 bit。这个问题的最有预测器可以通过贝叶斯分析（Murphy，2012）获得：

![img](https:////upload-images.jianshu.io/upload_images/42741-14516e87942ba169.png?imageMogr2/auto-orient/strip|imageView2/2/w/527/format/webp)

图 13

其中 $$c$$ 是在前面的上下文中的 5 个bit，$$B$$ 则是下一个 bit 的值，而 $$N_0$$ 和 $$N_1$$ 在序列中目前为止�对应于 0 和 1 的次数。因此，我们可以将 NTM 和 LSTM 进行对比。为了衡量性能，我们使用了一个从 1000 个 长度为 200 的序列，从和训练数据同样的分布中采样出来的。如图 13 所示，NTM 获得了小的但是显著地性能提升，但是并没有达到最优的代价。这两种架构在观察到新的输入时的进化在图 14 中进行了展示，并加上最优预测进行比对。NTM 内存使用情况的分析（图 15）表明控制器使用内存来计算有多少个 1 和 0，已经在不同的上下文中看到了，这样使得能够实现类似于最优估计的算法。

![img](https:////upload-images.jianshu.io/upload_images/42741-7beb32cfcdc9bbb2.png?imageMogr2/auto-orient/strip|imageView2/2/w/593/format/webp)

图 14

![img](https:////upload-images.jianshu.io/upload_images/42741-422652f8e2ab0e89.png?imageMogr2/auto-orient/strip|imageView2/2/w/608/format/webp)

图 15

## 4.5 优先级排序

![img](https:////upload-images.jianshu.io/upload_images/42741-ac8eb25cbe2502a4.png?imageMogr2/auto-orient/strip|imageView2/2/w/591/format/webp)

图 16

这个任务测试 NTM 是否能对数据进行排序——重要的基本算法。随机二元序列向量的序列跟随一个标量的优先级作为网络的输入。优先级是从 $$[-1,1]$$ 之间进行均匀采样的。木i包含根据优先级进行排序后的二元向量，如图 16 所示。

![img](https:////upload-images.jianshu.io/upload_images/42741-b69905c869c61d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/594/format/webp)

图 17

每个输入序列包含 20 个二元向量，及对应的优先级，每个目标序列是输入中 $$16$$ 个最高优先级向量。NTM 的内存使用情况检查让我们得出一个假设，它使用优先级来确定每次写得相对位置。为了检测这个假设，我们拟合了一个优先级线性函数到观测的写位置。图 17 展示了由这个线性函数紧紧的匹配的观测到得些位置。同样还展示了网络从内存位置中读出是按照递增顺序，就是对排序的序列进行遍历。

![img](https:////upload-images.jianshu.io/upload_images/42741-ccc16e335326c44d.png?imageMogr2/auto-orient/strip|imageView2/2/w/395/format/webp)

图 18

图 18 中的学习曲线展示了使用了前驱控制器和 LSTM 控制器的 NTM 从本质上在这个任务上超过了 LSTM。注意到 8 个并行的读和写头需要用来在次任务上拥有最优的性能；这可能会反映出仅仅使用一元的向量操作就能够对向量进行排序的难度。

## 4.6 实验细节

对所有的实验，RMSProp 算法用来进行训练，按照 Graves 2013 的研究形式并以 momentum 为 $$0.9$$。表 1 到 3 给出了网络配置和学习率的细节。所有的 LSTM 网络有三个 stacked 隐藏层。注意 LSTM 参数的数量随着隐藏元的个数以平方增长（由于递归链接的缘故）。这个和 NTM 不同，其中参数的数量并不会随着内存位置的数量而增加。在反向传播训练中，所有的梯度部分都限制在 $$(-10,10)$$ 之间。

![img](https:////upload-images.jianshu.io/upload_images/42741-5ffec48ec7545d52.png?imageMogr2/auto-orient/strip|imageView2/2/w/548/format/webp)

表 1

![img](https:////upload-images.jianshu.io/upload_images/42741-2d1c285f491b9a77.png?imageMogr2/auto-orient/strip|imageView2/2/w/565/format/webp)

表 2

![img](https:////upload-images.jianshu.io/upload_images/42741-8526be866c22ab66.png?imageMogr2/auto-orient/strip|imageView2/2/w/404/format/webp)

表 3

# 5 总结

我们介绍了 NTM，一种从生物可行内存和数字计算机的启发产生的神经网络架构。如同传统的神经网络，这个架构也是可微的端对端的并且可以通过梯度下降进行训练。我们的实验展示了它有能力从样本数据中学习简单的算法并且能够将这些算法推广到更多的超越了训练样本本身的数据上。

# 6 致谢

Many have offered thoughtful insights, but we would especially like to thank Daan Wierstra,
 Peter Dayan, Ilya Sutskever, Charles Blundell, Joel Veness, Koray Kavukcuoglu,
 Dharshan Kumaran, Georg Ostrovski, Chris Summerfield, Jeff Dean, Geoffrey Hinton, and
 Demis Hassabis



14人点赞



[deep learning]()





作者：朱小虎XiaohuZhu
链接：https://www.jianshu.com/p/94dabe29a43b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

此文转载，结合[《模仿游戏》](https://www.jianshu.com/p/77669e28230d)观看效果更佳。
 作者：宋方敏（南京大学，计算机软件新技术国家重点实验室，南京，210093）



# 引言

美国 TIME 杂志在 1999 年出版专卷介绍 20 世纪 100 个最伟大的智者，在计算机科学领域中英国数理逻辑学家 Alan Turing 列入其中（数学有 Kurt Gödel，物理有 Albert Einstein, 后来 Einstein 列为 The person of the 20th century）。由于 Turing 对于人类的极出贡献，他成为20世纪最有影响科学家和思想家之一。本文介绍 Alan Turing 的生平和主要工作，以此纪念计算机科学的奠基人。

# Turing评说

在数理逻辑的神秘王国里，一个天才提出了质疑和构想——设计一台能够模拟人类思维演段的机器—— 一个天方夜谭？

如果 Turing 所做的一切只是回答了神秘的数理逻辑领域里的一个令人苦恼的问题的话，那么就不会有什么理由让外行人记住他。但正相反，Turing 使用他那给整个世界带来巨大影响的方法，向世人展示——“一个封闭的逻辑系统里的某些命题是不能在本系统内得到证明的”——这一曾令 Kurt Gödel 名声大振的推论。这个年轻而前卫的剑桥大学学生所做的就是梦想着造一台假想的机器——一台简洁而精巧，打字机模样的，可以扫描或读入那些写在（理论上）无限长的磁带上的指令的机器。随着扫描器在磁带上移来移去——机器依据指令按序执行或跳转，从而，Turing 提出，机器执行过程的输出可以重现人类的思维。

这种受灵感启发的思想实验中的机器，连同 Turing 的另一个想法，很快获得了一个名字：Turing 机。因为磁带上的指令可以控制机器的行为，所以通过更换相应的指令就可以让这台机器去完成所有这样的机器所能完成的任务。换句话说，通过扫描不同的磁带，同样的一台机器既可以算题，又能下棋，还会做其它的相对更自然的任一件事。于是，他的机器又赢得了一个更好听的新名字：通用 Turing 机。

随着指令的运行，这样一台十分原始的硬件组合可以完成令人惊讶的各种任务。这样的想法听起来可能吗？在 1937 年显然是无法想象的。那一年，Turing 的学术论文 On Computable Numbers, with an Application to the Entscheidungsproblem发表在伦敦数学会学报上。但是 Turing 的想法被很少的读者所理解,他们认为这些构思在理论上十分有趣和诱人，却没有人认识到 Turing 的机器为后来的电子数字计算机勾画出了蓝图。

由于今天的计算机继承了如此之多的想法和技术上的创新，以至于我们无论将发明计算机的功劳归在谁的头上都是鲁莽的。但事实是，每敲击一次键盘或打开一扇窗口，抑或是运行一个字处理程序都是在一台 Turing 机的化身上工作。

Turing 1937 年的论文改变了他的一生，让一个腼腆而脆弱的男人更多地被卷入到尘世中去，最终走向一个悲剧式的结局。

Alan Mathison Turing 1912年生于伦敦，是这个家庭的第二个孩子。他的父亲是印度 British Civil Service 的成员，但他的母亲认为这样的环境不利于孩子的成长。于是 Alan 和哥哥在英国的一个领养家庭中度过了他们的童年,除了偶尔回家看看，大部分时间和父母分开。也许就是这其间 Turing 的孤独感诱发了他一生对人脑机理的兴趣——当上帝赐予的这个世界显得贫瘠和令人不满的时候，怎样创造一个属于自己的世界呢？

Turing 从 13 岁起就读于 Dorset 的 Sherbourne 小学，在那里，他已经显示出了自己的数学天赋，尽管他的卷子总是因为杂乱无章而被批评。Turing 在读小学的时候就发现了自己的同性恋倾向，并爱上了学校里的另一个小男孩——虽然 Turing 从未告诉过任何人——后来这个小男孩猝死于结核。这一事件粉碎了 Turing 的宗教信仰，使他成为了一个无神论者，并让他坚信所有的现象都有一个客观的解释。机器没有思想，而大脑中也没有灵魂。那么，思维和意识又是从何而来呢？

在两次向剑桥大学 Trinity College 这所令全世界的数学家们神往的学府申请资助失败之后，Turing 终于获得了 King’s College 的资助。在诸如 John Maynard Keynes 以及 E.M. Forster 这些名家泰斗们的指引下，King’s College 为 Turing 提供了充分自由与宽松的环境。尽管他被 King’s College 的核心学术圈以行为不够检点的理由而拒之门外，Turing 还是得到了巨大的发展。并且当他获得了学位证书之后，Turing 成了 King’s College 的一名导师。而如果不是后来的 Turing 机的诞生和二次大战的爆发，Turing 恐怕只会在数理逻辑的世界里慢条斯理、优哉游哉地生活一辈子了。

![img](https:////upload-images.jianshu.io/upload_images/42741-c7594ebb2ac9b0b8.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

模仿游戏

由于 Turing 发表的一系列论文，他被召入政府 Code and Cypher School。这所学院在一个叫做 Bletchley Park 的维多利亚风格的大厦里。这里囫囵吞枣似的聚集了那些被认为有可能攻破纳粹通信密码的人，包括数学家、国际象棋大师、古埃及研究学家等等。因为这项工程受到了严格的保密，Turing 在这里的工作直到他去世后才得以公之于众。正如计算机的问世一般，Bletchley Park 的工作也是众人共同智慧的结晶。而 Turing 的角色更是重中之重——他设计了一台原始的类似计算机的机器，用以高速破译北大西洋上纳粹 U-艇间通信的密码。

二战后，Turing 回到了剑桥，他希望能够重新拾回他所向往的宁静的研究生活。与此同时，国家物理实验室新近成立了一个数学分支——这个千载难逢的机遇使得 Turing 能够设计出真正的 Turing machine（即ACE —— Automatic Computing Engine）—— Turing 欣然前往。然而事实并不如人意，官僚主义、繁文缛节，事不关己、高高挂起之风盛行于时。战争年代里的那种晨兴夜寐、攻苦食淡的精神早已荡然无存。Turing 的提议不是被束之高阁就是被全然否定。Turing 决定离开 NPL，而后他在剑桥小憩，最终来到了曼彻斯特大学。这里的实验室正在根据他 1937 年提出的构想建造一台计算机。

Turing 自发表第一篇论文以来，就一直致力于拓展其关于会思考的机器的设想。他甚至提出，一台会思考的机器可以学习并编制指令。1950 年，在著名的英国哲学期刊 Mind 上，Turing 提出了“模仿测试”的概念（后来被称做“Turing 测试”）。比如在一封闭的屋子里，一提问人可以向另一个人与一台机器发问。若提问人不能通过二者的回答辨别出哪一个是人，哪一个是机器的话，则这台机器就被认为能够象人类一样地“思考”。

Turing 在人工智能支持者的心目中仍是一位英雄——其原因部分来自于 Turing 对未来的一个乐观的估计：“未来的某一天，女士们带着她们的计算机在公园里散步，她们说：‘我的计算机告诉我这真是个快乐的早晨！’”

不幸的是，美好的憧憬总让路于残酷的现实。在曼彻斯特的时候，一天他因遭抢劫而报警，那时他正和另一个同性恋男子在一起，而这个人很可能为罪犯所认识。Turing 从不隐瞒自己的同性恋倾向，但这次却使他身陷囹圄。同性恋在当时的英国仍是极重的罪名，1952 年，Turing 被判决为“严重猥亵罪”。不久他被减刑，并被要求注射雌性荷尔蒙以去除其同性欲望。一次，Turing 对他的朋友说：“我变得越来越有女人味了！”在 1954 年 6 月 7 日，Turing 食注有氰化钾的苹果自尽, 当时他只有 41 岁。





# Turing 机简介

Alan Turing 在1936提出了非凡的 Turing 机概念，从而定义出可计算性，Turing 的思法是基于对人们用笔和纸来实现一个算法的分析，他把这样的过程看作下列两种非常简单的动作。

（1）写上或擦去某个符号。
 （2）把注意从纸的某个部位转移到另一个部位。

而在每个阶段，算法说明下一次要做的动作。这样就依赖于（a）行为者当前观注的纸上某个部位上的符号和（b）行为者思维的当前状态。为了达到实现算法的目的，假定这完全由此算法以及迄今为止的运算记录来确定。这可能为编入一个部分的记录，但这不反映行为者的心情、智力和理解力。而且由于行为者是有穷的，故他只能处于有穷个互异状态。当然行为者的状态能转为此阶段已执行的动作。Turing 以此法设计一种有穷机器来执行算法，后来这类机器被称为 Turing 机。

下面我们给出 Turing 机的定义。一个 Turing 机 ![M](https://math.jianshu.com/math?formula=M) 是一个有穷装置其在一条纸带上执行运算。这条纸带向两端无限延伸且在两个方向上都已画上了无穷多个方格。（参见图１）

![img](https:////upload-images.jianshu.io/upload_images/42741-42bc18b561812ee0.png?imageMogr2/auto-orient/strip|imageView2/2/w/540/format/webp)

纸带代表人类行为者算题时的纸，而每个方格代表即时运作的一个部分。在运算时只有有穷格被利用，但我们事先不知道要用多少个格子。纸带是无穷的代表人类在计算时可无限量提供白纸。在任何时刻，纸带上的每个方格要么空白，要么含某个符号，这些符号取自M的字母表固定的一列符号 ![S_1，S_2, \cdots, S_n](https://math.jianshu.com/math?formula=S_1%EF%BC%8CS_2%2C%20%5Ccdots%2C%20S_n)。下以 ![B](https://math.jianshu.com/math?formula=B) 表示空白且把 ![B](https://math.jianshu.com/math?formula=B) 看作 ![S](https://math.jianshu.com/math?formula=S)。属于 ![M](https://math.jianshu.com/math?formula=M) 的字母表。![M](https://math.jianshu.com/math?formula=M) 有一个读头，它在任何时候都扫描着纸带的单个方格。（参见图２）

![img](https:////upload-images.jianshu.io/upload_images/42741-c2a3b69a2b5b88d0.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp)

![M](https://math.jianshu.com/math?formula=M) 可在纸带上进行三种简单动作：

1. 擦去正被扫描方格的符号且把它换成 ![M](https://math.jianshu.com/math?formula=M) 字母表中的另一符号。
2. 把读头移至正被扫描方格的右边的方格。
3. 把读头移至正被扫描方格的左边的方格。

在任何给定时刻，![M](https://math.jianshu.com/math?formula=M) 处于某个状态，![M](https://math.jianshu.com/math?formula=M) 的状态总共有有穷个，可设为 ![q_1,\cdots,q_m](https://math.jianshu.com/math?formula=q_1%2C%5Ccdots%2Cq_m)，在运作中，![M](https://math.jianshu.com/math?formula=M) 的状态是可变的。我们可设想 ![M](https://math.jianshu.com/math?formula=M) 的当前状态![q](https://math.jianshu.com/math?formula=q) 展示于 ![M](https://math.jianshu.com/math?formula=M) 的外体上（参见图2），认为此 ![q](https://math.jianshu.com/math?formula=q) 既部分指导当今做了什么以及今后将做什么。

在任何时刻 ![M](https://math.jianshu.com/math?formula=M) 采取的行动取决于 ![M](https://math.jianshu.com/math?formula=M) 的当前状态以及正被扫描的符号，这样的依赖关系被用 ![M](https://math.jianshu.com/math?formula=M) 的说明来描述，![M](https://math.jianshu.com/math?formula=M) 的说明 ![Q](https://math.jianshu.com/math?formula=Q) 是由有穷个四元组构成，每个四元组呈下形：![q_i s_j s_k q_l,q_i s_j R q_l,q_i s_j L_q l_p](https://math.jianshu.com/math?formula=q_i%20s_j%20s_k%20q_l%2Cq_i%20s_j%20R%20q_l%2Cq_i%20s_j%20L_q%20l_p) 这里 ![1≤i,l≤m,O≤j,k≤n](https://math.jianshu.com/math?formula=1%E2%89%A4i%2Cl%E2%89%A4m%2CO%E2%89%A4j%2Ck%E2%89%A4n), ![Q](https://math.jianshu.com/math?formula=Q) 中的四元组 ![q_is_jαq_l](https://math.jianshu.com/math?formula=q_is_j%CE%B1q_l) 说明当 ![M](https://math.jianshu.com/math?formula=M) 处于状态 ![q_i](https://math.jianshu.com/math?formula=q_i) 且正扫描于 ![S_j](https://math.jianshu.com/math?formula=S_j) 时 ![M](https://math.jianshu.com/math?formula=M) 将采取的动作如下：

1. 带上运算
    1.1. 若 ![\alpha＝S_k](https://math.jianshu.com/math?formula=%5Calpha%EF%BC%9DS_k) 则擦去 ![S_j](https://math.jianshu.com/math?formula=S_j),同时在当前方格中写上 ![S_k](https://math.jianshu.com/math?formula=S_k)
    1.2. 若 ![\alpha＝R](https://math.jianshu.com/math?formula=%5Calpha%EF%BC%9DR)，将读头向右移一格
    1.3. 若 ![\alpha＝L](https://math.jianshu.com/math?formula=%5Calpha%EF%BC%9DL)，将读头向左移一格
2. 转成状态 ![q_l](https://math.jianshu.com/math?formula=q_l)
    ![M](https://math.jianshu.com/math?formula=M) 的说明 ![Q](https://math.jianshu.com/math?formula=Q) 需要对每个对 ![q_i s_j](https://math.jianshu.com/math?formula=q_i%20s_j) 至多存在一个呈形 ![q_i s_j \alpha \beta](https://math.jianshu.com/math?formula=q_i%20s_j%20%5Calpha%20%5Cbeta) 的四元组于 ![Q](https://math.jianshu.com/math?formula=Q) 中，否则会导到 ![M](https://math.jianshu.com/math?formula=M) 下个动作的不确定。

为了进行计算，必须为 ![M](https://math.jianshu.com/math?formula=M) 提供一条纸带以及确定 ![M](https://math.jianshu.com/math?formula=M) 当前所扫描的方格，而且指定 ![M](https://math.jianshu.com/math?formula=M) 的初始状态。然后，假设 ![M](https://math.jianshu.com/math?formula=M) 当前状态为 ![q_i](https://math.jianshu.com/math?formula=q_i) 且正扫描符号 ![S_j](https://math.jianshu.com/math?formula=S_j), 若在 ![M](https://math.jianshu.com/math?formula=M) 的说明 ![Q](https://math.jianshu.com/math?formula=Q) 中，有呈形 ![q_is_j \alpha q_l](https://math.jianshu.com/math?formula=q_is_j%20%5Calpha%20q_l) 的四元组，则 ![M](https://math.jianshu.com/math?formula=M) 将如上所述地动作。这种动作将重复于新状态和正被扫描的符号，![M](https://math.jianshu.com/math?formula=M) 将尽可能地如此进行下去。![M](https://math.jianshu.com/math?formula=M) 的动作终止仅当其状态为 ![q_i](https://math.jianshu.com/math?formula=q_i) 且正扫描着 ![S_j](https://math.jianshu.com/math?formula=S_j) 使 ![Q](https://math.jianshu.com/math?formula=Q) 中不存在呈形 ![q_i s_j \alpha \beta](https://math.jianshu.com/math?formula=q_i%20s_j%20%5Calpha%20%5Cbeta) 的 ![Q](https://math.jianshu.com/math?formula=Q) 元组，即 ![Q](https://math.jianshu.com/math?formula=Q) 中无四元组其指示下一步做什么，当然这种情况永不发生。
 **例** 该 ![M](https://math.jianshu.com/math?formula=M) 的一个 Turing 机其字母表为 ![\{B，O，1\}](https://math.jianshu.com/math?formula=%5C%7BB%EF%BC%8CO%EF%BC%8C1%5C%7D) 且其可能状态为 ![q_1](https://math.jianshu.com/math?formula=q_1) 和 ![q_2](https://math.jianshu.com/math?formula=q_2)，![M](https://math.jianshu.com/math?formula=M) 的说明为

![q_1 0 R q_1](https://math.jianshu.com/math?formula=q_1%200%20R%20q_1)
 ![q_1 1 0 q_2](https://math.jianshu.com/math?formula=q_1%201%200%20q_2)
 ![q_2 0 R q_2](https://math.jianshu.com/math?formula=q_2%200%20R%20q_2)
 ![q_2 1 R q_1](https://math.jianshu.com/math?formula=q_2%201%20R%20q_1)

假设为 ![M](https://math.jianshu.com/math?formula=M) 提供的纸带为

![img](https:////upload-images.jianshu.io/upload_images/42741-612017c41b809bc5.png?imageMogr2/auto-orient/strip|imageView2/2/w/541/format/webp)

若为 ![M](https://math.jianshu.com/math?formula=M) 提供的纸带的每个方格为 ![0](https://math.jianshu.com/math?formula=0) 或 ![1](https://math.jianshu.com/math?formula=1)，则 ![M](https://math.jianshu.com/math?formula=M) 不停机。

由上例可看出，Turing 机 ![M](https://math.jianshu.com/math?formula=M) 是在纸带上实行算法的一个装置，算法的全部内容含于 ![M](https://math.jianshu.com/math?formula=M) 的说明 ![Q](https://math.jianshu.com/math?formula=Q) 中理论上，Turing 机被定义成某个 ![Q](https://math.jianshu.com/math?formula=Q) 元组集合，而不是实际上构造的物理 Turing 机。

为了把 Turing 机当作计算数论函数，我们首先在纸带上表示数，例如设 ![Ｍ](https://math.jianshu.com/math?formula=%EF%BC%AD) 的字母表中含 ![1](https://math.jianshu.com/math?formula=1)，把 ![1](https://math.jianshu.com/math?formula=1) 看作“小木棒”，用连续的 ![n+1](https://math.jianshu.com/math?formula=n%2B1) 个“![1](https://math.jianshu.com/math?formula=1)”表示 ![n](https://math.jianshu.com/math?formula=n)。

![img](https:////upload-images.jianshu.io/upload_images/42741-1641ec2a4be8a838.png?imageMogr2/auto-orient/strip|imageView2/2/w/541/format/webp)

约定，![\bar{n} =1^{n+1}](https://math.jianshu.com/math?formula=%5Cbar%7Bn%7D%20%3D1%5E%7Bn%2B1%7D), 对于 ![m](https://math.jianshu.com/math?formula=m) 元组 ![(n_1, \cdots, n_m)](https://math.jianshu.com/math?formula=(n_1%2C%20%5Ccdots%2C%20n_m)), 其对应的带表达式为 ![\bar{n}_1 B \bar{n}_2 B\cdots B \bar{n}_m](https://math.jianshu.com/math?formula=%5Cbar%7Bn%7D_1%20B%20%5Cbar%7Bn%7D_2%20B%5Ccdots%20B%20%5Cbar%7Bn%7D_m)

**定义**：设 ![f](https://math.jianshu.com/math?formula=f) 为从 ![N](https://math.jianshu.com/math?formula=N) 到 ![N](https://math.jianshu.com/math?formula=N) 的部分函数，Turing 机 ![Ｍ](https://math.jianshu.com/math?formula=%EF%BC%AD) 计算 ![f(n)](https://math.jianshu.com/math?formula=f(n)) 指若为 ![M](https://math.jianshu.com/math?formula=M) 提供上面的纸带，初始状态为 ![q_1](https://math.jianshu.com/math?formula=q_1) 且箭头标出正扫描的方格，则

![img](https:////upload-images.jianshu.io/upload_images/42741-509a0a058e3b9d66.png?imageMogr2/auto-orient/strip|imageView2/2/w/530/format/webp)

对于 ![m](https://math.jianshu.com/math?formula=m) 元部分函数 ![f(x_1,\cdots,x_m)](https://math.jianshu.com/math?formula=f(x_1%2C%5Ccdots%2Cx_m)) , ![M](https://math.jianshu.com/math?formula=M) 计算 ![f](https://math.jianshu.com/math?formula=f) 指 ![M](https://math.jianshu.com/math?formula=M) 始于状态 ![q_1](https://math.jianshu.com/math?formula=q_1) 且提供如下纸带且由箭头指出正被扫描的方格：

![img](https:////upload-images.jianshu.io/upload_images/42741-d210c6145fc89794.png?imageMogr2/auto-orient/strip|imageView2/2/w/534/format/webp)

若 ![Ｍ](https://math.jianshu.com/math?formula=%EF%BC%AD) 计算终止则 ![f(x_1,\cdots,x_m)](https://math.jianshu.com/math?formula=f(x_1%2C%5Ccdots%2Cx_m)) 为带上 ![1](https://math.jianshu.com/math?formula=1) 的总数否则 ![f(x_1,\cdots,x_m)](https://math.jianshu.com/math?formula=f(x_1%2C%5Ccdots%2Cx_m)) 无定义。

**例** 加法 ![n+m](https://math.jianshu.com/math?formula=n%2Bm) 可由如下的 Turing 机计算：

![Ｍ](https://math.jianshu.com/math?formula=%EF%BC%AD) 的字母表为 ![\{B,1\}](https://math.jianshu.com/math?formula=%5C%7BB%2C1%5C%7D)，![Ｍ](https://math.jianshu.com/math?formula=%EF%BC%AD) 的说明 ![Q](https://math.jianshu.com/math?formula=Q) 为
 ![q_11Bq_1](https://math.jianshu.com/math?formula=q_11Bq_1)
 ![q_1BRq_2](https://math.jianshu.com/math?formula=q_1BRq_2)
 ![q_21Bq_3](https://math.jianshu.com/math?formula=q_21Bq_3)
 ![q_2BRq_2](https://math.jianshu.com/math?formula=q_2BRq_2)
 情况１：![n≠0](https://math.jianshu.com/math?formula=n%E2%89%A00)
 ![q_1^{n+1} B 1^{m+1}→q_1 B 1^n B 1^{m+1}→B q_2 1^n B 1^{m+1}→B q_3 B 1^{n-1} B 1^{m+1}](https://math.jianshu.com/math?formula=q_1%5E%7Bn%2B1%7D%20B%201%5E%7Bm%2B1%7D%E2%86%92q_1%20B%201%5En%20B%201%5E%7Bm%2B1%7D%E2%86%92B%20q_2%201%5En%20B%201%5E%7Bm%2B1%7D%E2%86%92B%20q_3%20B%201%5E%7Bn-1%7D%20B%201%5E%7Bm%2B1%7D) 停。
 情况２：![n=0](https://math.jianshu.com/math?formula=n%3D0)
 ![q_1 1 B 1^{m+1}→q_1 B B 1^{m+1}→B q_2 B 1^{m+1}→B B q_2 1^{m+1}→B B q_3 B 1^m](https://math.jianshu.com/math?formula=q_1%201%20B%201%5E%7Bm%2B1%7D%E2%86%92q_1%20B%20B%201%5E%7Bm%2B1%7D%E2%86%92B%20q_2%20B%201%5E%7Bm%2B1%7D%E2%86%92B%20B%20q_2%201%5E%7Bm%2B1%7D%E2%86%92B%20B%20q_3%20B%201%5Em)

**定义**：一个部分数论函数是 Turing 可计算的指存在 Turing 机其计算之。这样就定义了什么是可计算的。由以上知 ![n+m](https://math.jianshu.com/math?formula=n%2Bm) 是 Turing 的计算的，事实上 Turing 的计算能力非常强大，一切的递归函数都是 Turing 可计算的，可以证明任何一种程序设计语言所能计算的函数一定是 Turing 可计算的，为此现在人们接受 Church-Turing 论点：一切直觉可计算的函数是 Turing 可计算的。

# Turing生平

## 1912--

Alan Turing 出生于 1912 年 6 月 23 日，伦敦。他的父亲 Julius Mathison Turing，是印度 British Civil Service 成员。他经常在国外。Alan 的母亲 Ethel Sara Stoney 是 Madras 铁路总工程师的女儿。Alan 的父母在印度相遇，并在那儿结了婚。当 Alan 大约一岁时，他的母亲在印度与丈夫相聚。而 Alan 留在了英国，与这个家庭的朋友待在一起。之后, Alan 被送入学校，但这似乎没有使其受到任何好处，因此，几个月后，他离开了学校。接下来，他又被送往 Hazlehurst Preparatory 学校，在那儿，他在许多课程上获得了中上的成绩，但他相当有主见。在学习生涯中他对棋类产生了兴趣，并且加入了辩论社。

## 1926--

他通过了常规入学考试，随后进入了学校。1926 年，Turing 恰遇大罢工，当罢工正进行中，他骑车 60 英里从家来到学校。虽然母亲坚定的认为他必须接受公立学校的教育，但 Turing 发现他很难成为学校所期望的那样。许多有独创思想的思想家发现学校是一个几乎无法理解的过程，Turing 便是一例。他的天赋驱使他朝自己的方向发展而无需老师。

Turing 因书法而被批评，为英语而奋争，甚至在数学上他采用自己的方法而不用老师所教授的解题法。在 Sherborne 期间，尽管是非常规的方法，Turing 仍然赢得了几乎所有的数学奖。从早期起，Turing 就对化学中的一个课题很感兴趣，他按自己的日程安排做试验，这使得他的老师很不高兴。 Turing 的校长认为：如果他留在公立学校,他必须以接受教育为目标。如果他仅想成为科学专家，在公立学校就是浪费时间。这话远超出了对 Turing 自身的意义，他说明了图灵所遇到的学校体制。虽然，他的老师可能并不清楚他在自学些什么,但 Turing 在校期间学习了深奥的数学知识。他阅读了 Einstein 的关于相对论的论文，还通过 Eddington 的“物质世界的性质”了解量子力学。

1928 年，发生了影响 Turing 一生的事。他与 Christopher Morcom 年长其一岁的学生，产生了亲密的友谊，并且两人共同工作于科学事业。也许，这是 Turing 第一次找到一位有共同思想的人。可是 Morcom 于1930年2月去世。这对 Turing 是一个沉重的打击。在 Morcom 生病期间，Turing 就有死亡的预感。他感到这是科学无法解释的。之后，他写到：**这些事实是不难解释的，但我感到惊奇！**

## 1931--

尽管学校这几年的艰难，Turing 仍然在 1931 年进入了剑桥皇家学院学习数学。这并非易事。1929 年，Turing 参加了奖学金考试，他赢得了一个展现机会而非奖学金。因对这一结果的不满，Turing 在第二年又参加了考试，这一次他获得了奖学金。剑桥较其他学校对像这样的非常规学生而言是一个相对较舒适的环境。他现在更能探索自己的思想，在 1933 年他读了 的数学哲学入门。同时，他读了 Neumann 关于量子力学的 1932 年的文章。这是一个其一生反复研究过的课题。

1933 年，Turing 开始对数理逻辑感兴趣。Turing 读了一篇关于“数学和逻辑”的文章。他提出数学的纯逻辑的观点是不足的，数学命题具有多种解释，逻辑只是一种。1933 年，德国希特勒上台，英国爆发了反战运动。Turing 加入了反战运动，但他没有随波逐流去信仰某些主义。Turing 毕业於 1934 年，在 1935 年的春天,他参加了 Max Mewman 的关于数学基础的高级教程。这一课程研究了 Gödel 不完全性结果和 Hilbert 的可判定性问题。某种意义上来说，可判定性是一个简单的问题，亦即给定一个数学命题，是否能找到一个决定命题是真或假的算法。对于大多数命题来说，寻找这样一个算法是简单的。真正的难点在于证明对于确定的命题，这样的算法不存在。当给出了一个解决某一问题的算法，很明显它确实是一个算法，然而没有关于算法的足够严谨的定义使得可证明算法的不存在性。Turing 开始对这些问题进行研究。1935 年，图灵因一篇关于高斯的误差函数（证明概率理论的基本结果，亦即中心极限定理）的论文而当选为剑桥皇家学院的成员。虽然中心极限定理已被发现，但 Turing 并不知道，他独立的发现了它。1936 年, Turing 成为一位 Smith 奖得主。

## 1937--

现在，Turing 在剑桥的成就被用来说明他在概率理论上的工作。然而，自从他参加了 Newman 的课程后，他就开始做可判定性问题的研究了。1936 年,他发表了On Computable Numbers, with an Application to the Entscheidungsproblem 的学术文章。在这篇论文中，Turing 引入了抽象机的概念（现被称为 Turing 机）。Turing 机利用有限的规则（由一张有限表给出）及从带子上读入一个符号，从一种状态转换到另一状态。Turing 机可输入或删除带子上的一个字符。Turing 写到：记录下的一些字符将会形成正在计算的实数的小数的数字序列。其他的则只是一些粗略的符号用来”协助存储”，应被删除。

他将可计算数定义为小数扩展位可通过 Turing 机从空白带子产生的实数。他指出那即可计算的，但由于仅可数的实数是可计算的，多数实数是不可计算的，因此，他给出了不可计算的数的描述，并指出由于他在限定条件下描述了一个不能在限定条件下描述的数，从而，这显得有些矛盾。但 Turing 明白这显然的矛盾的根源。给定指令表的 Turing 机是否输出无限序列的数（用另一 Turing 机实现）是无法判决的。

虽然，这篇论文包含着对数学和计算机科学均有相当价值的观点，但在伦敦数学会学报上发表它却不是那么容易的。原因是 Alonzo Church 於 1936 年在美国数学期刊上发表了一个初等数论不可解问题，同样证明对于算术无判定过程。Turing 的方法与 Church 有相当的差别，但在伦敦数学会期刊出版它之前，Newman 为此费尽唇舌。Turing 的修改稿提到了 Church 的结果于 1936 年 4 月首次完成，同年 8 月修改的论文，这篇修改稿於 1937 年发表。

与 Church 讨论的好处在于，1936 年 Turing 成为普林斯顿大学的研究生。在普林斯顿 Church 的指导下, Turing 了解了研究的方法。1938 年,他返回英国。1937 年，Turing 回英国度暑假邂逅 Wittgenstein。他在普林斯顿的工作主要是基于序数的逻辑系统，发表于 1939 年。Newman 认为：这篇论文充满了有趣的设想和观点……他展现了 Turing 的直觉及数学证明方面的东西。

在这篇论文发表之前，Turing 发表了两篇更常规的数学论题方面的论文。一篇是讨论通过有限群逼近 Lie 群的方法，另一篇证明了扩展群的结果并给出了更简单和系统的方法。（Reinhold Baer 首次证明了这一结果），Turing 在 Turing 机上的工作最引人注目的是在现实技术所能构造之前，他已描述了现代计算机。他在 1936 年的论文中证明通用 Turing 机的存在：能用来做任何特殊目的的机器的工作，亦即若有恰当的指令输入，可进行任何计算。

尽管对 Turing 来说，“计算机”是一个执行计算的人，但我们必须从他对广义 Turing 机的描述中看到我们今天的计算机加装有程序的带子即 Turing 机。在普林斯顿期间，Turing 设想过构造计算机。1938 年，他一回到剑桥就开始构造 analogue mechanical device 用来研究 Riemann 猜想，这是当今许多人认为的最难解决的数学问题。然而，在国家密码机构邀请他回来破译德国密码之后，他的工作呈现出新的面貌。

## 1939--

当 1939 年二战爆发，Turing 立即在政府设在 Bletchley 公园的译码和解码部门进行工作。虽然官方对在那里开展的工作进行了严格的保密，但现在大部分内幕已被公开。Turing在密码学和计算机方面的天才帮助破译小组破译了不少密码，拯救了无数士兵的生命。那一段时间对于他是一生中最快乐的时间, 充分发挥了他的才能。
 Turing 和另一位数学家 Welchman 一起在波兰数学家早期工作的基础上发展了 Bombe 机，这台机从 40 年代末对所有从 Luftwaffe 的密码机发出的消息进行了译码。德国海军的密码机的编码很难被破译，但这正是 Turing 所感兴趣的挑战。在 1941 年中期，Turing 在统计学和信息捕获方面的进展，使得德国海军的信号在 Bletchley 被破译。

从 1942 年 11 月到 1943 年 3 月 Turing 在美国进行解码和一个语音保密系统的研究工作。德国人加密方式的改变意味着 Bletchley 失去了破译消息的能力。尽管 Turing 并没有直接参与到成功破译更多的密码工作中，但他的思想的重要性在这项工作中得到充分体现。1945 年, Turing 由于在战争中所作出的贡献而获得了 OBE 奖。

## 1946--

二战后，Turing 被伦敦国家物理实验室邀请去参与计算机的设计。他在 1946 年提交了一份关于自动计算机器的报告。用现代人的观点看来，Turing 当时所提出的设想是一份有关计算机的原始的详细设计。他为 ACE(自动计算机器)设计的存储器的大小被当时大多数人认为是毫无希望和过于夸张的，以至于在这个项目被批准前被耽误了好一阵。

在 1947 到 1948 学年 Turing 回到了剑桥，在那里他的研究兴趣不再是计算机和数学了，令人惊奇的是，他竟然研究神经学和生理学。在这期间，他并没有忘了计算机，而且他还为计算机编写代码。不过他的学术研究太广泛了，二战后他还认真研究了人类学。Walton 运动俱乐部记录表明，Turing 作为会员曾赢得了 3 英里和 10 英里的冠军。1947 年他参加了 A.A.A 马拉松比赛，获得第 15 名。

1948 年 Newman 成为曼彻斯特大学的数学教授，在那里他为 Turing 提供学者基金。于是 Turing 从国家物理实验室回到了曼彻斯特。Newman 写到：期望 Turing 能领导开展该项目中的数学工作。一段时间能继续工作下去，为已建造好的机器设计例行程序，然后当这些工作稳定后，继续数论分析方面的一般性问题研究。工作从由 FC Williams 和 T Kilburn 提出的计算机的构造开始。

## 1950--

1950 年，Turing 在计算机和人工智能方面作出了极为卓越的成就。1950 年，Turing 发表了里程碑式的论文“机器能思考吗？”，他预测了随着计算机发展将会出现的问题。他研究了人工智能领域的核心问题。时至今日人们还用他发表的这篇论文中所提出的 Turing 测试来尝试回答电脑是否具有智能。

Turing 没有忘记判定性问题是他那些具有深远意义的数学论文的起点。群论中的一个主要问题是：在一个有限群中给定任意一个字，是否存在一个算法判定这个字等于单位。Post 已经证明半群中不存在这样一个算法。虽然一开始 Turing 已经证明了对于群有同样一个结论，但在就对他证明做一个讨论会上，他发现了一个错误。他从自己不完善的证明中发现一个消去的半群有不可解字问题。Turing 在1950 年发表了这个结果。1957 年勃恩通过 Turing 的这篇论文中的思想证明了存在一个有不可解字问题的群。

主要因为在他 1936 年提出的“Turing机”方面所做的工作，Turing 在1951年当选为伦敦皇家学院的会员。到 1951 年为止，他致力于将数学应用到生物组织研究中去。1952 年他公布了在地貌形成方面，关于在有机生命体中模式和组织的演化的一部分研究工作。

## 1952--

1952 年 Turing 在警察局报告一宗同性恋事件的细节时被捕，他被指控违反了英国同性恋法令。而他去警察局是因为他遭到了勒索。1952 年 3 月 31 日，他作为一位同性恋者被审判，他认为他自己没错，未给自己辩护。然而，他被判为有罪。当时，他只有两条路可走：坐牢或注射激素。他选择了后者，并继续他广泛的学术研究。

他不仅在地貌形成的研究中有进一步进展，而且他还在量子理论和相对论的研究中提出了新的思想，即用旋量来表示初等粒子。在 Bletchley 公园的译码工作成了图灵在 GCHQ 进行译码和人工智能研究工作的基础。在冷战期间，译码成为一项重要的工作，Turing 继续为 GCHQ 工作，尽管他在曼彻斯特的同事还没完全意识到这一点。在他被定罪后，他失去了安全保障。但更糟糕的是，安全部门的官员将他这位知识渊博，在 GCHQ 开展工作的学者定为安全方面的危险分子。由于学术需要，Turing 有许多外国同事，但警察开始调查他的国外来访者。1953 年Turing 在希腊的一次度假引起了安全人员的恐慌。1954 年 6 月 7 日，Turing 在寓所身亡，他的床头有一个咬了一半的苹果，经解剖，发现是剧毒氰化物致死，那个苹果是在氰化物溶液中浸泡过的，经调查，Turing 为自杀，但他母亲始终认为这是一个偶然事件。

# 结束语

Turing 不仅是一位数学家、逻辑学和计算机科学家，而且他更是一位哲学家，科学哲学家，他问出：“什么是计算”以及“机器能思考吗”使我们受到哲学精神的震撼，他虽然是这个尘世的匆匆过客，但他是勇敢的智者，他的发明将影响人类的思维，他是欧洲上空划过的灿烂的流星。他是人类历史上的大智者。人们将永远怀念他，美国 ACM 设 Turing 奖，以此纪念。



29人点赞



[大猫小记]()





作者：朱小虎XiaohuZhu
链接：https://www.jianshu.com/p/54ce45be064f
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。